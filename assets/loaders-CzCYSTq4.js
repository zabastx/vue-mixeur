import{D as ys,H as pt,R as Ge,a as qe,L as le,b as ft,F as It,c as it,d as rn,e as Ne,f as Ue,S as ne,B as ke,g as nt,I as yn,C as ae,h as Se,i as Tn,j as Ve,T as wn,k as ot,l as Ot,m as Ft,M as Qe,n as Ts,E as ws,o as Q,G as Xe,p as Pt,P as at,O as ze,q as En,r as Dt,s as pe,t as xn,u as Sn,v as An,w as yt,x as st,y as In,V as re,z as bn,A as Es,J as xe,U as xs,K as Ss,N as Gt,Q as As,W as Is,X as De,Y as Rn,Z as Ie,_ as kt,$ as Tt,a0 as Nt,a1 as bs,a2 as Re,a3 as Rs,a4 as _s,a5 as vs,a6 as _n,a7 as Ls,a8 as Ms,a9 as Cs,aa as vn,ab as Os,ac as Je,ad as rt,ae as Ln,af as Fs,ag as et,ah as Ut,ai as Ps,aj as gt,ak as Ds,al as ks,am as Mn,an as Ns,ao as Us,ap as Bs,aq as Hs,ar as Gs,as as js}from"./three-EndpCsJ0.js";import{u as tt,N as zs,t as on}from"./index-CXlcdIph.js";class qr extends ys{constructor(e){super(e),this.type=pt,this.outputFormat=Ge}parse(e){const fe=Math.pow(2.7182818,2.2);function ue(o,u){let f=0;for(let E=0;E<65536;++E)(E==0||o[E>>3]&1<<(E&7))&&(u[f++]=E);const g=f-1;for(;f<65536;)u[f++]=0;return g}function ce(o){for(let u=0;u<16384;u++)o[u]={},o[u].len=0,o[u].lit=0,o[u].p=null}const me={l:0,c:0,lc:0};function lt(o,u,f,g,E){for(;f<o;)u=u<<8|en(g,E),f+=8;f-=o,me.l=u>>f&(1<<o)-1,me.c=u,me.lc=f}const Ze=new Array(59);function kn(o){for(let f=0;f<=58;++f)Ze[f]=0;for(let f=0;f<65537;++f)Ze[o[f]]+=1;let u=0;for(let f=58;f>0;--f){const g=u+Ze[f]>>1;Ze[f]=u,u=g}for(let f=0;f<65537;++f){const g=o[f];g>0&&(o[f]=g|Ze[g]++<<6)}}function Nn(o,u,f,g,E,R){const m=u;let _=0,A=0;for(;g<=E;g++){if(m.value-u.value>f)return!1;lt(6,_,A,o,m);const S=me.l;if(_=me.c,A=me.lc,R[g]=S,S==63){if(m.value-u.value>f)throw new Error("Something wrong with hufUnpackEncTable");lt(8,_,A,o,m);let b=me.l+6;if(_=me.c,A=me.lc,g+b>E+1)throw new Error("Something wrong with hufUnpackEncTable");for(;b--;)R[g++]=0;g--}else if(S>=59){let b=S-59+2;if(g+b>E+1)throw new Error("Something wrong with hufUnpackEncTable");for(;b--;)R[g++]=0;g--}}kn(R)}function jt(o){return o&63}function zt(o){return o>>6}function Un(o,u,f,g){for(;u<=f;u++){const E=zt(o[u]),R=jt(o[u]);if(E>>R)throw new Error("Invalid table entry");if(R>14){const m=g[E>>R-14];if(m.len)throw new Error("Invalid table entry");if(m.lit++,m.p){const _=m.p;m.p=new Array(m.lit);for(let A=0;A<m.lit-1;++A)m.p[A]=_[A]}else m.p=new Array(1);m.p[m.lit-1]=u}else if(R){let m=0;for(let _=1<<14-R;_>0;_--){const A=g[(E<<14-R)+m];if(A.len||A.p)throw new Error("Invalid table entry");A.len=R,A.lit=u,m++}}}return!0}const ve={c:0,lc:0};function wt(o,u,f,g){o=o<<8|en(f,g),u+=8,ve.c=o,ve.lc=u}const Le={c:0,lc:0};function Et(o,u,f,g,E,R,m,_,A){if(o==u){g<8&&(wt(f,g,E,R),f=ve.c,g=ve.lc),g-=8;let S=f>>g;if(S=new Uint8Array([S])[0],_.value+S>A)return!1;const b=m[_.value-1];for(;S-- >0;)m[_.value++]=b}else if(_.value<A)m[_.value++]=o;else return!1;Le.c=f,Le.lc=g}function xt(o){return o&65535}function Vt(o){const u=xt(o);return u>32767?u-65536:u}const J={a:0,b:0};function Be(o,u){const f=Vt(o),E=Vt(u),R=f+(E&1)+(E>>1),m=R,_=R-E;J.a=m,J.b=_}function He(o,u){const f=xt(o),g=xt(u),E=f-(g>>1)&65535,R=g+E-32768&65535;J.a=R,J.b=E}function Bn(o,u,f,g,E,R,m){const _=m<16384,A=f>E?E:f;let S=1,b,M;for(;S<=A;)S<<=1;for(S>>=1,b=S,S>>=1;S>=1;){M=0;const v=M+R*(E-b),O=R*S,U=R*b,C=g*S,D=g*b;let B,Z,Y,ie;for(;M<=v;M+=U){let W=M;const G=M+g*(f-b);for(;W<=G;W+=D){const te=W+C,oe=W+O,$=oe+C;_?(Be(o[W+u],o[oe+u]),B=J.a,Y=J.b,Be(o[te+u],o[$+u]),Z=J.a,ie=J.b,Be(B,Z),o[W+u]=J.a,o[te+u]=J.b,Be(Y,ie),o[oe+u]=J.a,o[$+u]=J.b):(He(o[W+u],o[oe+u]),B=J.a,Y=J.b,He(o[te+u],o[$+u]),Z=J.a,ie=J.b,He(B,Z),o[W+u]=J.a,o[te+u]=J.b,He(Y,ie),o[oe+u]=J.a,o[$+u]=J.b)}if(f&S){const te=W+O;_?Be(o[W+u],o[te+u]):He(o[W+u],o[te+u]),B=J.a,o[te+u]=J.b,o[W+u]=B}}if(E&S){let W=M;const G=M+g*(f-b);for(;W<=G;W+=D){const te=W+C;_?Be(o[W+u],o[te+u]):He(o[W+u],o[te+u]),B=J.a,o[te+u]=J.b,o[W+u]=B}}b=S,S>>=1}return M}function Hn(o,u,f,g,E,R,m,_,A){let S=0,b=0;const M=m,v=Math.trunc(g.value+(E+7)/8);for(;g.value<v;)for(wt(S,b,f,g),S=ve.c,b=ve.lc;b>=14;){const U=S>>b-14&16383,C=u[U];if(C.len)b-=C.len,Et(C.lit,R,S,b,f,g,_,A,M),S=Le.c,b=Le.lc;else{if(!C.p)throw new Error("hufDecode issues");let D;for(D=0;D<C.lit;D++){const B=jt(o[C.p[D]]);for(;b<B&&g.value<v;)wt(S,b,f,g),S=ve.c,b=ve.lc;if(b>=B&&zt(o[C.p[D]])==(S>>b-B&(1<<B)-1)){b-=B,Et(C.p[D],R,S,b,f,g,_,A,M),S=Le.c,b=Le.lc;break}}if(D==C.lit)throw new Error("hufDecode issues")}}const O=8-E&7;for(S>>=O,b-=O;b>0;){const U=u[S<<14-b&16383];if(U.len)b-=U.len,Et(U.lit,R,S,b,f,g,_,A,M),S=Le.c,b=Le.lc;else throw new Error("hufDecode issues")}return!0}function Xt(o,u,f,g,E,R){const m={value:0},_=f.value,A=Te(u,f),S=Te(u,f);f.value+=4;const b=Te(u,f);if(f.value+=4,A<0||A>=65537||S<0||S>=65537)throw new Error("Something wrong with HUF_ENCSIZE");const M=new Array(65537),v=new Array(16384);ce(v);const O=g-(f.value-_);if(Nn(o,f,O,A,S,M),b>8*(g-(f.value-_)))throw new Error("Something wrong with hufUncompress");Un(M,A,S,v),Hn(M,v,o,f,b,S,R,E,m)}function Gn(o,u,f){for(let g=0;g<f;++g)u[g]=o[u[g]]}function Kt(o){for(let u=1;u<o.length;u++){const f=o[u-1]+o[u]-128;o[u]=f}}function Zt(o,u){let f=0,g=Math.floor((o.length+1)/2),E=0;const R=o.length-1;for(;!(E>R||(u[E++]=o[f++],E>R));)u[E++]=o[g++]}function Wt(o){let u=o.byteLength;const f=new Array;let g=0;const E=new DataView(o);for(;u>0;){const R=E.getInt8(g++);if(R<0){const m=-R;u-=m+1;for(let _=0;_<m;_++)f.push(E.getUint8(g++))}else{const m=R;u-=2;const _=E.getUint8(g++);for(let A=0;A<m+1;A++)f.push(_)}}return f}function jn(o,u,f,g,E,R){let m=new DataView(R.buffer);const _=f[o.idx[0]].width,A=f[o.idx[0]].height,S=3,b=Math.floor(_/8),M=Math.ceil(_/8),v=Math.ceil(A/8),O=_-(M-1)*8,U=A-(v-1)*8,C={value:0},D=new Array(S),B=new Array(S),Z=new Array(S),Y=new Array(S),ie=new Array(S);for(let G=0;G<S;++G)ie[G]=u[o.idx[G]],D[G]=G<1?0:D[G-1]+M*v,B[G]=new Float32Array(64),Z[G]=new Uint16Array(64),Y[G]=new Uint16Array(M*64);for(let G=0;G<v;++G){let te=8;G==v-1&&(te=U);let oe=8;for(let X=0;X<M;++X){X==M-1&&(oe=O);for(let q=0;q<S;++q)Z[q].fill(0),Z[q][0]=E[D[q]++],Yt(C,g,Z[q]),qt(Z[q],B[q]),$t(B[q]);Vn(B);for(let q=0;q<S;++q)Qt(B[q],Y[q],X*64)}let $=0;for(let X=0;X<S;++X){const q=f[o.idx[X]].type;for(let _e=8*G;_e<8*G+te;++_e){$=ie[X][_e];for(let Ye=0;Ye<b;++Ye){const Ae=Ye*64+(_e&7)*8;m.setUint16($+0*q,Y[X][Ae+0],!0),m.setUint16($+2*q,Y[X][Ae+1],!0),m.setUint16($+4*q,Y[X][Ae+2],!0),m.setUint16($+6*q,Y[X][Ae+3],!0),m.setUint16($+8*q,Y[X][Ae+4],!0),m.setUint16($+10*q,Y[X][Ae+5],!0),m.setUint16($+12*q,Y[X][Ae+6],!0),m.setUint16($+14*q,Y[X][Ae+7],!0),$+=16*q}}if(b!=M)for(let _e=8*G;_e<8*G+te;++_e){const Ye=ie[X][_e]+8*b*2*q,Ae=b*64+(_e&7)*8;for(let ht=0;ht<oe;++ht)m.setUint16(Ye+ht*2*q,Y[X][Ae+ht],!0)}}}const W=new Uint16Array(_);m=new DataView(R.buffer);for(let G=0;G<S;++G){f[o.idx[G]].decoded=!0;const te=f[o.idx[G]].type;if(f[G].type==2)for(let oe=0;oe<A;++oe){const $=ie[G][oe];for(let X=0;X<_;++X)W[X]=m.getUint16($+X*2*te,!0);for(let X=0;X<_;++X)m.setFloat32($+X*2*te,P(W[X]),!0)}}}function zn(o,u,f,g,E,R){const m=new DataView(R.buffer),_=f[o],A=_.width,S=_.height,b=Math.ceil(A/8),M=Math.ceil(S/8),v=Math.floor(A/8),O=A-(b-1)*8,U=S-(M-1)*8,C={value:0};let D=0;const B=new Float32Array(64),Z=new Uint16Array(64),Y=new Uint16Array(b*64);for(let ie=0;ie<M;++ie){let W=8;ie==M-1&&(W=U);for(let G=0;G<b;++G)Z.fill(0),Z[0]=E[D++],Yt(C,g,Z),qt(Z,B),$t(B),Qt(B,Y,G*64);for(let G=8*ie;G<8*ie+W;++G){let te=u[o][G];for(let oe=0;oe<v;++oe){const $=oe*64+(G&7)*8;for(let X=0;X<8;++X)m.setUint16(te+X*2*_.type,Y[$+X],!0);te+=16*_.type}if(b!=v){const oe=v*64+(G&7)*8;for(let $=0;$<O;++$)m.setUint16(te+$*2*_.type,Y[oe+$],!0)}}}_.decoded=!0}function Yt(o,u,f){let g,E=1;for(;E<64;)g=u[o.value],g==65280?E=64:g>>8==255?E+=g&255:(f[E]=g,E++),o.value++}function qt(o,u){u[0]=P(o[0]),u[1]=P(o[1]),u[2]=P(o[5]),u[3]=P(o[6]),u[4]=P(o[14]),u[5]=P(o[15]),u[6]=P(o[27]),u[7]=P(o[28]),u[8]=P(o[2]),u[9]=P(o[4]),u[10]=P(o[7]),u[11]=P(o[13]),u[12]=P(o[16]),u[13]=P(o[26]),u[14]=P(o[29]),u[15]=P(o[42]),u[16]=P(o[3]),u[17]=P(o[8]),u[18]=P(o[12]),u[19]=P(o[17]),u[20]=P(o[25]),u[21]=P(o[30]),u[22]=P(o[41]),u[23]=P(o[43]),u[24]=P(o[9]),u[25]=P(o[11]),u[26]=P(o[18]),u[27]=P(o[24]),u[28]=P(o[31]),u[29]=P(o[40]),u[30]=P(o[44]),u[31]=P(o[53]),u[32]=P(o[10]),u[33]=P(o[19]),u[34]=P(o[23]),u[35]=P(o[32]),u[36]=P(o[39]),u[37]=P(o[45]),u[38]=P(o[52]),u[39]=P(o[54]),u[40]=P(o[20]),u[41]=P(o[22]),u[42]=P(o[33]),u[43]=P(o[38]),u[44]=P(o[46]),u[45]=P(o[51]),u[46]=P(o[55]),u[47]=P(o[60]),u[48]=P(o[21]),u[49]=P(o[34]),u[50]=P(o[37]),u[51]=P(o[47]),u[52]=P(o[50]),u[53]=P(o[56]),u[54]=P(o[59]),u[55]=P(o[61]),u[56]=P(o[35]),u[57]=P(o[36]),u[58]=P(o[48]),u[59]=P(o[49]),u[60]=P(o[57]),u[61]=P(o[58]),u[62]=P(o[62]),u[63]=P(o[63])}function $t(o){const u=.5*Math.cos(.7853975),f=.5*Math.cos(3.14159/16),g=.5*Math.cos(3.14159/8),E=.5*Math.cos(3*3.14159/16),R=.5*Math.cos(5*3.14159/16),m=.5*Math.cos(3*3.14159/8),_=.5*Math.cos(7*3.14159/16),A=new Array(4),S=new Array(4),b=new Array(4),M=new Array(4);for(let v=0;v<8;++v){const O=v*8;A[0]=g*o[O+2],A[1]=m*o[O+2],A[2]=g*o[O+6],A[3]=m*o[O+6],S[0]=f*o[O+1]+E*o[O+3]+R*o[O+5]+_*o[O+7],S[1]=E*o[O+1]-_*o[O+3]-f*o[O+5]-R*o[O+7],S[2]=R*o[O+1]-f*o[O+3]+_*o[O+5]+E*o[O+7],S[3]=_*o[O+1]-R*o[O+3]+E*o[O+5]-f*o[O+7],b[0]=u*(o[O+0]+o[O+4]),b[3]=u*(o[O+0]-o[O+4]),b[1]=A[0]+A[3],b[2]=A[1]-A[2],M[0]=b[0]+b[1],M[1]=b[3]+b[2],M[2]=b[3]-b[2],M[3]=b[0]-b[1],o[O+0]=M[0]+S[0],o[O+1]=M[1]+S[1],o[O+2]=M[2]+S[2],o[O+3]=M[3]+S[3],o[O+4]=M[3]-S[3],o[O+5]=M[2]-S[2],o[O+6]=M[1]-S[1],o[O+7]=M[0]-S[0]}for(let v=0;v<8;++v)A[0]=g*o[16+v],A[1]=m*o[16+v],A[2]=g*o[48+v],A[3]=m*o[48+v],S[0]=f*o[8+v]+E*o[24+v]+R*o[40+v]+_*o[56+v],S[1]=E*o[8+v]-_*o[24+v]-f*o[40+v]-R*o[56+v],S[2]=R*o[8+v]-f*o[24+v]+_*o[40+v]+E*o[56+v],S[3]=_*o[8+v]-R*o[24+v]+E*o[40+v]-f*o[56+v],b[0]=u*(o[v]+o[32+v]),b[3]=u*(o[v]-o[32+v]),b[1]=A[0]+A[3],b[2]=A[1]-A[2],M[0]=b[0]+b[1],M[1]=b[3]+b[2],M[2]=b[3]-b[2],M[3]=b[0]-b[1],o[0+v]=M[0]+S[0],o[8+v]=M[1]+S[1],o[16+v]=M[2]+S[2],o[24+v]=M[3]+S[3],o[32+v]=M[3]-S[3],o[40+v]=M[2]-S[2],o[48+v]=M[1]-S[1],o[56+v]=M[0]-S[0]}function Vn(o){for(let u=0;u<64;++u){const f=o[0][u],g=o[1][u],E=o[2][u];o[0][u]=f+1.5747*E,o[1][u]=f-.1873*g-.4682*E,o[2][u]=f+1.8556*g}}function Qt(o,u,f){for(let g=0;g<64;++g)u[f+g]=rn.toHalfFloat(Xn(o[g]))}function Xn(o){return o<=1?Math.sign(o)*Math.pow(Math.abs(o),2.2):Math.sign(o)*Math.pow(fe,Math.abs(o)-1)}function St(o){return new DataView(o.array.buffer,o.offset.value,o.size)}function Kn(o){const u=o.viewer.buffer.slice(o.offset.value,o.offset.value+o.size),f=new Uint8Array(Wt(u)),g=new Uint8Array(f.length);return Kt(f),Zt(f,g),new DataView(g.buffer)}function At(o){const u=o.array.slice(o.offset.value,o.offset.value+o.size),f=tt(u),g=new Uint8Array(f.length);return Kt(f),Zt(f,g),new DataView(g.buffer)}function Zn(o){const u=o.viewer,f={value:o.offset.value},g=new Uint16Array(o.columns*o.lines*(o.inputChannels.length*o.type)),E=new Uint8Array(8192);let R=0;const m=new Array(o.inputChannels.length);for(let U=0,C=o.inputChannels.length;U<C;U++)m[U]={},m[U].start=R,m[U].end=m[U].start,m[U].nx=o.columns,m[U].ny=o.lines,m[U].size=o.type,R+=m[U].nx*m[U].ny*m[U].size;const _=We(u,f),A=We(u,f);if(A>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(_<=A)for(let U=0;U<A-_+1;U++)E[U+_]=Me(u,f);const S=new Uint16Array(65536),b=ue(E,S),M=Te(u,f);Xt(o.array,u,f,M,g,R);for(let U=0;U<o.inputChannels.length;++U){const C=m[U];for(let D=0;D<m[U].size;++D)Bn(g,C.start+D,C.nx,C.size,C.ny,C.nx*C.size,b)}Gn(S,g,R);let v=0;const O=new Uint8Array(g.buffer.byteLength);for(let U=0;U<o.lines;U++)for(let C=0;C<o.inputChannels.length;C++){const D=m[C],B=D.nx*D.size,Z=new Uint8Array(g.buffer,D.end*2,B*2);O.set(Z,v),v+=B*2,D.end+=B}return new DataView(O.buffer)}function Wn(o){const u=o.array.slice(o.offset.value,o.offset.value+o.size),f=tt(u),g=o.inputChannels.length*o.lines*o.columns*o.totalBytes,E=new ArrayBuffer(g),R=new DataView(E);let m=0,_=0;const A=new Array(4);for(let S=0;S<o.lines;S++)for(let b=0;b<o.inputChannels.length;b++){let M=0;switch(o.inputChannels[b].pixelType){case 1:A[0]=m,A[1]=A[0]+o.columns,m=A[1]+o.columns;for(let O=0;O<o.columns;++O){const U=f[A[0]++]<<8|f[A[1]++];M+=U,R.setUint16(_,M,!0),_+=2}break;case 2:A[0]=m,A[1]=A[0]+o.columns,A[2]=A[1]+o.columns,m=A[2]+o.columns;for(let O=0;O<o.columns;++O){const U=f[A[0]++]<<24|f[A[1]++]<<16|f[A[2]++]<<8;M+=U,R.setUint32(_,M,!0),_+=4}break}}return R}function Jt(o){const u=o.viewer,f={value:o.offset.value},g=new Uint8Array(o.columns*o.lines*(o.inputChannels.length*o.type*2)),E={version:ge(u,f),unknownUncompressedSize:ge(u,f),unknownCompressedSize:ge(u,f),acCompressedSize:ge(u,f),dcCompressedSize:ge(u,f),rleCompressedSize:ge(u,f),rleUncompressedSize:ge(u,f),rleRawSize:ge(u,f),totalAcUncompressedCount:ge(u,f),totalDcUncompressedCount:ge(u,f),acCompression:ge(u,f)};if(E.version<2)throw new Error("EXRLoader.parse: "+Fe.compression+" version "+E.version+" is unsupported");const R=new Array;let m=We(u,f)-2;for(;m>0;){const C=ut(u.buffer,f),D=Me(u,f),B=D>>2&3,Z=(D>>4)-1,Y=new Int8Array([Z])[0],ie=Me(u,f);R.push({name:C,index:Y,type:ie,compression:B}),m-=C.length+3}const _=Fe.channels,A=new Array(o.inputChannels.length);for(let C=0;C<o.inputChannels.length;++C){const D=A[C]={},B=_[C];D.name=B.name,D.compression=0,D.decoded=!1,D.type=B.pixelType,D.pLinear=B.pLinear,D.width=o.columns,D.height=o.lines}const S={idx:new Array(3)};for(let C=0;C<o.inputChannels.length;++C){const D=A[C];for(let B=0;B<R.length;++B){const Z=R[B];D.name==Z.name&&(D.compression=Z.compression,Z.index>=0&&(S.idx[Z.index]=C),D.offset=C)}}let b,M,v;if(E.acCompressedSize>0)switch(E.acCompression){case 0:b=new Uint16Array(E.totalAcUncompressedCount),Xt(o.array,u,f,E.acCompressedSize,b,E.totalAcUncompressedCount);break;case 1:const C=o.array.slice(f.value,f.value+E.totalAcUncompressedCount),D=tt(C);b=new Uint16Array(D.buffer),f.value+=E.totalAcUncompressedCount;break}if(E.dcCompressedSize>0){const C={array:o.array,offset:f,size:E.dcCompressedSize};M=new Uint16Array(At(C).buffer),f.value+=E.dcCompressedSize}if(E.rleRawSize>0){const C=o.array.slice(f.value,f.value+E.rleCompressedSize),D=tt(C);v=Wt(D.buffer),f.value+=E.rleCompressedSize}let O=0;const U=new Array(A.length);for(let C=0;C<U.length;++C)U[C]=new Array;for(let C=0;C<o.lines;++C)for(let D=0;D<A.length;++D)U[D].push(O),O+=A[D].width*o.type*2;S.idx[0]!==void 0&&A[S.idx[0]]&&jn(S,U,A,b,M,g);for(let C=0;C<A.length;++C){const D=A[C];if(!D.decoded)switch(D.compression){case 2:let B=0,Z=0;for(let Y=0;Y<o.lines;++Y){let ie=U[C][B];for(let W=0;W<D.width;++W){for(let G=0;G<2*D.type;++G)g[ie++]=v[Z+G*D.width*D.height];Z++}B++}break;case 1:zn(C,U,A,b,M,g);break;default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(g.buffer)}function ut(o,u){const f=new Uint8Array(o);let g=0;for(;f[u.value+g]!=0;)g+=1;const E=new TextDecoder().decode(f.slice(u.value,u.value+g));return u.value=u.value+g+1,E}function Yn(o,u,f){const g=new TextDecoder().decode(new Uint8Array(o).slice(u.value,u.value+f));return u.value=u.value+f,g}function qn(o,u){const f=ye(o,u),g=Te(o,u);return[f,g]}function $n(o,u){const f=Te(o,u),g=Te(o,u);return[f,g]}function ye(o,u){const f=o.getInt32(u.value,!0);return u.value=u.value+4,f}function Te(o,u){const f=o.getUint32(u.value,!0);return u.value=u.value+4,f}function en(o,u){const f=o[u.value];return u.value=u.value+1,f}function Me(o,u){const f=o.getUint8(u.value);return u.value=u.value+1,f}const ge=function(o,u){let f;return"getBigInt64"in DataView.prototype?f=Number(o.getBigInt64(u.value,!0)):f=o.getUint32(u.value+4,!0)+Number(o.getUint32(u.value,!0)<<32),u.value+=8,f};function he(o,u){const f=o.getFloat32(u.value,!0);return u.value+=4,f}function Qn(o,u){return rn.toHalfFloat(he(o,u))}function P(o){const u=(o&31744)>>10,f=o&1023;return(o>>15?-1:1)*(u?u===31?f?NaN:1/0:Math.pow(2,u-15)*(1+f/1024):6103515625e-14*(f/1024))}function We(o,u){const f=o.getUint16(u.value,!0);return u.value+=2,f}function Jn(o,u){return P(We(o,u))}function es(o,u,f,g){const E=f.value,R=[];for(;f.value<E+g-1;){const m=ut(u,f),_=ye(o,f),A=Me(o,f);f.value+=3;const S=ye(o,f),b=ye(o,f);R.push({name:m,pixelType:_,pLinear:A,xSampling:S,ySampling:b})}return f.value+=1,R}function ts(o,u){const f=he(o,u),g=he(o,u),E=he(o,u),R=he(o,u),m=he(o,u),_=he(o,u),A=he(o,u),S=he(o,u);return{redX:f,redY:g,greenX:E,greenY:R,blueX:m,blueY:_,whiteX:A,whiteY:S}}function ns(o,u){const f=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],g=Me(o,u);return f[g]}function ss(o,u){const f=ye(o,u),g=ye(o,u),E=ye(o,u),R=ye(o,u);return{xMin:f,yMin:g,xMax:E,yMax:R}}function rs(o,u){const f=["INCREASING_Y","DECREASING_Y","RANDOM_Y"],g=Me(o,u);return f[g]}function is(o,u){const f=["ENVMAP_LATLONG","ENVMAP_CUBE"],g=Me(o,u);return f[g]}function os(o,u){const f=["ONE_LEVEL","MIPMAP_LEVELS","RIPMAP_LEVELS"],g=["ROUND_DOWN","ROUND_UP"],E=Te(o,u),R=Te(o,u),m=Me(o,u);return{xSize:E,ySize:R,levelMode:f[m&15],roundingMode:g[m>>4]}}function as(o,u){const f=he(o,u),g=he(o,u);return[f,g]}function cs(o,u){const f=he(o,u),g=he(o,u),E=he(o,u);return[f,g,E]}function ls(o,u,f,g,E){if(g==="string"||g==="stringvector"||g==="iccProfile")return Yn(u,f,E);if(g==="chlist")return es(o,u,f,E);if(g==="chromaticities")return ts(o,f);if(g==="compression")return ns(o,f);if(g==="box2i")return ss(o,f);if(g==="envmap")return is(o,f);if(g==="tiledesc")return os(o,f);if(g==="lineOrder")return rs(o,f);if(g==="float")return he(o,f);if(g==="v2f")return as(o,f);if(g==="v3f")return cs(o,f);if(g==="int")return ye(o,f);if(g==="rational")return qn(o,f);if(g==="timecode")return $n(o,f);if(g==="preview")return f.value+=E,"skipped";f.value+=E}function us(o,u){const f=Math.log2(o);return u=="ROUND_DOWN"?Math.floor(f):Math.ceil(f)}function hs(o,u,f){let g=0;switch(o.levelMode){case"ONE_LEVEL":g=1;break;case"MIPMAP_LEVELS":g=us(Math.max(u,f),o.roundingMode)+1;break;case"RIPMAP_LEVELS":throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")}return g}function tn(o,u,f,g){const E=new Array(o);for(let R=0;R<o;R++){const m=1<<R;let _=u/m|0;g=="ROUND_UP"&&_*m<u&&(_+=1);const A=Math.max(_,1);E[R]=(A+f-1)/f|0}return E}function ps(){const o=this,u=o.offset,f={value:0};for(let g=0;g<o.tileCount;g++){const E=ye(o.viewer,u),R=ye(o.viewer,u);u.value+=8,o.size=Te(o.viewer,u);const m=E*o.blockWidth,_=R*o.blockHeight;o.columns=m+o.blockWidth>o.width?o.width-m:o.blockWidth,o.lines=_+o.blockHeight>o.height?o.height-_:o.blockHeight;const A=o.columns*o.totalBytes,b=o.size<o.lines*A?o.uncompress(o):St(o);u.value+=o.size;for(let M=0;M<o.lines;M++){const v=M*o.columns*o.totalBytes;for(let O=0;O<o.inputChannels.length;O++){const U=Fe.channels[O].name,C=o.channelByteOffsets[U]*o.columns,D=o.decodeChannels[U];if(D===void 0)continue;f.value=v+C;const B=(o.height-(1+_+M))*o.outLineWidth;for(let Z=0;Z<o.columns;Z++){const Y=B+(Z+m)*o.outputChannels+D;o.byteArray[Y]=o.getter(b,f)}}}}}function fs(){const o=this,u=o.offset,f={value:0};for(let g=0;g<o.height/o.blockHeight;g++){const E=ye(o.viewer,u)-Fe.dataWindow.yMin;o.size=Te(o.viewer,u),o.lines=E+o.blockHeight>o.height?o.height-E:o.blockHeight;const R=o.columns*o.totalBytes,_=o.size<o.lines*R?o.uncompress(o):St(o);u.value+=o.size;for(let A=0;A<o.blockHeight;A++){const S=g*o.blockHeight,b=A+o.scanOrder(S);if(b>=o.height)continue;const M=A*R,v=(o.height-1-b)*o.outLineWidth;for(let O=0;O<o.inputChannels.length;O++){const U=Fe.channels[O].name,C=o.channelByteOffsets[U]*o.columns,D=o.decodeChannels[U];if(D!==void 0){f.value=M+C;for(let B=0;B<o.columns;B++){const Z=v+B*o.outputChannels+D;o.byteArray[Z]=o.getter(_,f)}}}}}}function ds(o,u,f){const g={};if(o.getUint32(0,!0)!=20000630)throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");g.version=o.getUint8(4);const E=o.getUint8(5);g.spec={singleTile:!!(E&2),longName:!!(E&4),deepFormat:!!(E&8),multiPart:!!(E&16)},f.value=8;let R=!0;for(;R;){const m=ut(u,f);if(m==="")R=!1;else{const _=ut(u,f),A=Te(o,f),S=ls(o,u,f,_,A);S===void 0?console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${_}'.`):g[m]=S}}if((E&-7)!=0)throw console.error("THREE.EXRHeader:",g),new Error("THREE.EXRLoader: Provided file is currently unsupported.");return g}function ms(o,u,f,g,E,R){const m={size:0,viewer:u,array:f,offset:g,width:o.dataWindow.xMax-o.dataWindow.xMin+1,height:o.dataWindow.yMax-o.dataWindow.yMin+1,inputChannels:o.channels,channelByteOffsets:{},shouldExpand:!1,scanOrder:null,totalBytes:null,columns:null,lines:null,type:null,uncompress:null,getter:null,format:null,colorSpace:le};switch(o.compression){case"NO_COMPRESSION":m.blockHeight=1,m.uncompress=St;break;case"RLE_COMPRESSION":m.blockHeight=1,m.uncompress=Kn;break;case"ZIPS_COMPRESSION":m.blockHeight=1,m.uncompress=At;break;case"ZIP_COMPRESSION":m.blockHeight=16,m.uncompress=At;break;case"PIZ_COMPRESSION":m.blockHeight=32,m.uncompress=Zn;break;case"PXR24_COMPRESSION":m.blockHeight=16,m.uncompress=Wn;break;case"DWAA_COMPRESSION":m.blockHeight=32,m.uncompress=Jt;break;case"DWAB_COMPRESSION":m.blockHeight=256,m.uncompress=Jt;break;default:throw new Error("EXRLoader.parse: "+o.compression+" is unsupported")}const _={};for(const v of o.channels)switch(v.name){case"Y":case"R":case"G":case"B":case"A":_[v.name]=!0,m.type=v.pixelType}let A=!1,S=!1;if(_.R&&_.G&&_.B)m.outputChannels=4;else if(_.Y)m.outputChannels=1;else throw new Error("EXRLoader.parse: file contains unsupported data channels.");switch(m.outputChannels){case 4:R==Ge?(A=!_.A,m.format=Ge,m.colorSpace=le,m.outputChannels=4,m.decodeChannels={R:0,G:1,B:2,A:3}):R==qe?(m.format=qe,m.colorSpace=le,m.outputChannels=2,m.decodeChannels={R:0,G:1}):R==ft?(m.format=ft,m.colorSpace=le,m.outputChannels=1,m.decodeChannels={R:0}):S=!0;break;case 1:R==Ge?(A=!0,m.format=Ge,m.colorSpace=le,m.outputChannels=4,m.shouldExpand=!0,m.decodeChannels={Y:0}):R==qe?(m.format=qe,m.colorSpace=le,m.outputChannels=2,m.shouldExpand=!0,m.decodeChannels={Y:0}):R==ft?(m.format=ft,m.colorSpace=le,m.outputChannels=1,m.decodeChannels={Y:0}):S=!0;break;default:S=!0}if(S)throw new Error("EXRLoader.parse: invalid output format for specified file.");if(m.type==1)switch(E){case It:m.getter=Jn;break;case pt:m.getter=We;break}else if(m.type==2)switch(E){case It:m.getter=he;break;case pt:m.getter=Qn}else throw new Error("EXRLoader.parse: unsupported pixelType "+m.type+" for "+o.compression+".");m.columns=m.width;const b=m.width*m.height*m.outputChannels;switch(E){case It:m.byteArray=new Float32Array(b),A&&m.byteArray.fill(1,0,b);break;case pt:m.byteArray=new Uint16Array(b),A&&m.byteArray.fill(15360,0,b);break;default:console.error("THREE.EXRLoader: unsupported type: ",E);break}let M=0;for(const v of o.channels)m.decodeChannels[v.name]!==void 0&&(m.channelByteOffsets[v.name]=M),M+=v.pixelType*2;if(m.totalBytes=M,m.outLineWidth=m.width*m.outputChannels,o.lineOrder==="INCREASING_Y"?m.scanOrder=v=>v:m.scanOrder=v=>m.height-1-v,o.spec.singleTile){m.blockHeight=o.tiles.ySize,m.blockWidth=o.tiles.xSize;const v=hs(o.tiles,m.width,m.height),O=tn(v,m.width,o.tiles.xSize,o.tiles.roundingMode),U=tn(v,m.height,o.tiles.ySize,o.tiles.roundingMode);m.tileCount=O[0]*U[0];for(let C=0;C<v;C++)for(let D=0;D<U[C];D++)for(let B=0;B<O[C];B++)ge(u,g);m.decode=ps.bind(m)}else{m.blockWidth=m.width;const v=Math.ceil(m.height/m.blockHeight);for(let O=0;O<v;O++)ge(u,g);m.decode=fs.bind(m)}return m}const nn={value:0},sn=new DataView(e),gs=new Uint8Array(e),Fe=ds(sn,e,nn),Ce=ms(Fe,sn,gs,nn,this.type,this.outputFormat);if(Ce.decode(),Ce.shouldExpand){const o=Ce.byteArray;if(this.outputFormat==Ge)for(let u=0;u<o.length;u+=4)o[u+2]=o[u+1]=o[u];else if(this.outputFormat==qe)for(let u=0;u<o.length;u+=2)o[u+1]=o[u]}return{header:Fe,width:Ce.width,height:Ce.height,data:Ce.byteArray,format:Ce.format,colorSpace:Ce.colorSpace,type:this.type}}setDataType(e){return this.type=e,this}setOutputFormat(e){return this.outputFormat=e,this}load(e,t,s,n){function r(i,a){i.colorSpace=a.colorSpace,i.minFilter=it,i.magFilter=it,i.generateMipmaps=!1,i.flipY=!1,t&&t(i,a)}return super.load(e,r,s,n)}}const bt=new WeakMap;class Vs extends Ne{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,s,n){const r=new Ue(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,i=>{this.parse(i,t,n)},s,n)}parse(e,t,s=()=>{}){this.decodeDracoFile(e,t,null,null,ne,s).catch(s)}decodeDracoFile(e,t,s,n,r=le,i=()=>{}){const a={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!s,vertexColorSpace:r};return this.decodeGeometry(e,a).then(t).catch(i)}decodeGeometry(e,t){const s=JSON.stringify(t);if(bt.has(e)){const c=bt.get(e);if(c.key===s)return c.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const r=this.workerNextTaskID++,i=e.byteLength,a=this._getWorker(r,i).then(c=>(n=c,new Promise((l,h)=>{n._callbacks[r]={resolve:l,reject:h},n.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))).then(c=>this._createGeometry(c.geometry));return a.catch(()=>!0).then(()=>{n&&r&&this._releaseTask(n,r)}),bt.set(e,{key:s,promise:a}),a}_createGeometry(e){const t=new ke;e.index&&t.setIndex(new nt(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const{name:n,array:r,itemSize:i,stride:a,vertexColorSpace:c}=e.attributes[s];let l;if(i===a)l=new nt(r,i);else{const h=new yn(r,a);l=new Tn(h,i,0)}n==="color"&&(this._assignVertexColorSpace(l,c),l.normalized=!(r instanceof Float32Array)),t.setAttribute(n,l)}return t}_assignVertexColorSpace(e,t){if(t!==ne)return;const s=new ae;for(let n=0,r=e.count;n<r;n++)s.fromBufferAttribute(e,n),Se.colorSpaceToWorking(s,ne),e.setXYZ(n,s.r,s.g,s.b)}_loadLibrary(e,t){const s=new Ue(this.manager);return s.setPath(this.decoderPath),s.setResponseType(t),s.setWithCredentials(this.withCredentials),new Promise((n,r)=>{s.load(e,n,void 0,r)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(s=>{const n=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const r=Xs.toString(),i=["/* draco decoder */",n,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([i]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const n=new Worker(this.workerSourceURL);n._callbacks={},n._taskCosts={},n._taskLoad=0,n.postMessage({type:"init",decoderConfig:this.decoderConfig}),n.onmessage=function(r){const i=r.data;switch(i.type){case"decode":n._callbacks[i.id].resolve(i);break;case"error":n._callbacks[i.id].reject(i);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+i.type+'"')}},this.workerPool.push(n)}else this.workerPool.sort(function(n,r){return n._taskLoad>r._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=t,s._taskLoad+=t,s})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function Xs(){let T,e;onmessage=function(i){const a=i.data;switch(a.type){case"init":T=a.decoderConfig,e=new Promise(function(h){T.onModuleLoaded=function(p){h({draco:p})},DracoDecoderModule(T)});break;case"decode":const c=a.buffer,l=a.taskConfig;e.then(h=>{const p=h.draco,d=new p.Decoder;try{const y=t(p,d,new Int8Array(c),l),x=y.attributes.map(I=>I.array.buffer);y.index&&x.push(y.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:y},x)}catch(y){console.error(y),self.postMessage({type:"error",id:a.id,error:y.message})}finally{p.destroy(d)}});break}};function t(i,a,c,l){const h=l.attributeIDs,p=l.attributeTypes;let d,y;const x=a.GetEncodedGeometryType(c);if(x===i.TRIANGULAR_MESH)d=new i.Mesh,y=a.DecodeArrayToMesh(c,c.byteLength,d);else if(x===i.POINT_CLOUD)d=new i.PointCloud,y=a.DecodeArrayToPointCloud(c,c.byteLength,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!y.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+y.error_msg());const I={index:null,attributes:[]};for(const w in h){const L=self[p[w]];let k,F;if(l.useUniqueIDs)F=h[w],k=a.GetAttributeByUniqueId(d,F);else{if(F=a.GetAttributeId(d,i[h[w]]),F===-1)continue;k=a.GetAttribute(d,F)}const N=n(i,a,d,w,L,k);w==="color"&&(N.vertexColorSpace=l.vertexColorSpace),I.attributes.push(N)}return x===i.TRIANGULAR_MESH&&(I.index=s(i,a,d)),i.destroy(d),I}function s(i,a,c){const h=c.num_faces()*3,p=h*4,d=i._malloc(p);a.GetTrianglesUInt32Array(c,p,d);const y=new Uint32Array(i.HEAPF32.buffer,d,h).slice();return i._free(d),{array:y,itemSize:1}}function n(i,a,c,l,h,p){const d=c.num_points(),y=p.num_components(),x=r(i,h),I=y*h.BYTES_PER_ELEMENT,w=Math.ceil(I/4)*4,L=w/h.BYTES_PER_ELEMENT,k=d*I,F=d*w,N=i._malloc(k);a.GetAttributeDataArrayForAllPoints(c,p,x,k,N);const K=new h(i.HEAPF32.buffer,N,k/h.BYTES_PER_ELEMENT);let H;if(I===w)H=K.slice();else{H=new h(F/h.BYTES_PER_ELEMENT);let V=0;for(let ee=0,fe=K.length;ee<fe;ee++){for(let ue=0;ue<y;ue++)H[V+ue]=K[ee*y+ue];V+=L}}return i._free(N),{name:l,count:d,itemSize:y,array:H,stride:L}}function r(i,a){switch(a){case Float32Array:return i.DT_FLOAT32;case Int8Array:return i.DT_INT8;case Int16Array:return i.DT_INT16;case Int32Array:return i.DT_INT32;case Uint8Array:return i.DT_UINT8;case Uint16Array:return i.DT_UINT16;case Uint32Array:return i.DT_UINT32}}}const $r=Object.freeze(Object.defineProperty({__proto__:null,DRACOLoader:Vs},Symbol.toStringTag,{value:"Module"}));let j,se,de;class Ks extends Ne{constructor(e){super(e)}load(e,t,s,n){const r=this,i=r.path===""?Ve.extractUrlBase(e):r.path,a=new Ue(this.manager);a.setPath(r.path),a.setResponseType("arraybuffer"),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(c){try{t(r.parse(c,i))}catch(l){n?n(l):console.error(l),r.manager.itemError(e)}},s,n)}parse(e,t){if(Qs(e))j=new $s().parse(e);else{const n=Fn(e);if(!Js(n))throw new Error("THREE.FBXLoader: Unknown format.");if(cn(n)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+cn(n));j=new qs().parse(n)}const s=new wn(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Zs(s,this.manager).parse(j)}}class Zs{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){se=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),s=this.parseMaterials(t),n=this.parseDeformers(),r=new Ws().parse(n);return this.parseScene(n,r,s),de}parseConnections(){const e=new Map;return"Connections"in j&&j.Connections.connections.forEach(function(s){const n=s[0],r=s[1],i=s[2];e.has(n)||e.set(n,{parents:[],children:[]});const a={ID:r,relationship:i};e.get(n).parents.push(a),e.has(r)||e.set(r,{parents:[],children:[]});const c={ID:n,relationship:i};e.get(r).children.push(c)}),e}parseImages(){const e={},t={};if("Video"in j.Objects){const s=j.Objects.Video;for(const n in s){const r=s[n],i=parseInt(n);if(e[i]=r.RelativeFilename||r.Filename,"Content"in r){const a=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,c=typeof r.Content=="string"&&r.Content!=="";if(a||c){const l=this.parseImage(s[n]);t[r.RelativeFilename||r.Filename]=l}}}}for(const s in e){const n=e[s];t[n]!==void 0?e[s]=t[n]:e[s]=e[s].split("\\").pop()}return e}parseImage(e){const t=e.Content,s=e.RelativeFilename||e.Filename,n=s.slice(s.lastIndexOf(".")+1).toLowerCase();let r;switch(n){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",s),r="image/tga";break;case"webp":r="image/webp";break;default:console.warn('FBXLoader: Image type "'+n+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const i=new Uint8Array(t);return window.URL.createObjectURL(new Blob([i],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in j.Objects){const s=j.Objects.Texture;for(const n in s){const r=this.parseTexture(s[n],e);t.set(parseInt(n),r)}}return t}parseTexture(e,t){const s=this.loadTexture(e,t);s.ID=e.id,s.name=e.attrName;const n=e.WrapModeU,r=e.WrapModeV,i=n!==void 0?n.value:0,a=r!==void 0?r.value:0;if(s.wrapS=i===0?ot:Ot,s.wrapT=a===0?ot:Ot,"Scaling"in e){const c=e.Scaling.value;s.repeat.x=c[0],s.repeat.y=c[1]}if("Translation"in e){const c=e.Translation.value;s.offset.x=c[0],s.offset.y=c[1]}return s}loadTexture(e,t){const s=e.FileName.split(".").pop().toLowerCase();let n=this.manager.getHandler(`.${s}`);n===null&&(n=this.textureLoader);const r=n.path;r||n.setPath(this.textureLoader.path);const i=se.get(e.id).children;let a;if(i!==void 0&&i.length>0&&t[i[0].ID]!==void 0&&(a=t[i[0].ID],(a.indexOf("blob:")===0||a.indexOf("data:")===0)&&n.setPath(void 0)),a===void 0)return console.warn("FBXLoader: Undefined filename, creating placeholder texture."),new Ft;const c=n.load(a);return n.setPath(r),c}parseMaterials(e){const t=new Map;if("Material"in j.Objects){const s=j.Objects.Material;for(const n in s){const r=this.parseMaterial(s[n],e);r!==null&&t.set(parseInt(n),r)}}return t}parseMaterial(e,t){const s=e.id,n=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!se.has(s))return null;const i=this.parseParameters(e,t,s);let a;switch(r.toLowerCase()){case"phong":a=new Qe;break;case"lambert":a=new Ts;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),a=new Qe;break}return a.setValues(i),a.name=n,a}parseParameters(e,t,s){const n={};e.BumpFactor&&(n.bumpScale=e.BumpFactor.value),e.Diffuse?n.color=Se.colorSpaceToWorking(new ae().fromArray(e.Diffuse.value),ne):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(n.color=Se.colorSpaceToWorking(new ae().fromArray(e.DiffuseColor.value),ne)),e.DisplacementFactor&&(n.displacementScale=e.DisplacementFactor.value),e.Emissive?n.emissive=Se.colorSpaceToWorking(new ae().fromArray(e.Emissive.value),ne):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(n.emissive=Se.colorSpaceToWorking(new ae().fromArray(e.EmissiveColor.value),ne)),e.EmissiveFactor&&(n.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),n.opacity=1-(e.TransparencyFactor?parseFloat(e.TransparencyFactor.value):0),(n.opacity===1||n.opacity===0)&&(n.opacity=e.Opacity?parseFloat(e.Opacity.value):null,n.opacity===null&&(n.opacity=1-(e.TransparentColor?parseFloat(e.TransparentColor.value[0]):0))),n.opacity<1&&(n.transparent=!0),e.ReflectionFactor&&(n.reflectivity=e.ReflectionFactor.value),e.Shininess&&(n.shininess=e.Shininess.value),e.Specular?n.specular=Se.colorSpaceToWorking(new ae().fromArray(e.Specular.value),ne):e.SpecularColor&&e.SpecularColor.type==="Color"&&(n.specular=Se.colorSpaceToWorking(new ae().fromArray(e.SpecularColor.value),ne));const r=this;return se.get(s).children.forEach(function(i){const a=i.relationship;switch(a){case"Bump":n.bumpMap=r.getTexture(t,i.ID);break;case"Maya|TEX_ao_map":n.aoMap=r.getTexture(t,i.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":n.map=r.getTexture(t,i.ID),n.map!==void 0&&(n.map.colorSpace=ne);break;case"DisplacementColor":n.displacementMap=r.getTexture(t,i.ID);break;case"EmissiveColor":n.emissiveMap=r.getTexture(t,i.ID),n.emissiveMap!==void 0&&(n.emissiveMap.colorSpace=ne);break;case"NormalMap":case"Maya|TEX_normal_map":n.normalMap=r.getTexture(t,i.ID);break;case"ReflectionColor":n.envMap=r.getTexture(t,i.ID),n.envMap!==void 0&&(n.envMap.mapping=ws,n.envMap.colorSpace=ne);break;case"SpecularColor":n.specularMap=r.getTexture(t,i.ID),n.specularMap!==void 0&&(n.specularMap.colorSpace=ne);break;case"TransparentColor":case"TransparencyFactor":n.alphaMap=r.getTexture(t,i.ID),n.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),n}getTexture(e,t){return"LayeredTexture"in j.Objects&&t in j.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=se.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in j.Objects){const s=j.Objects.Deformer;for(const n in s){const r=s[n],i=se.get(parseInt(n));if(r.attrType==="Skin"){const a=this.parseSkeleton(i,s);a.ID=n,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=i.parents[0].ID,e[n]=a}else if(r.attrType==="BlendShape"){const a={id:n};a.rawTargets=this.parseMorphTargets(i,s),a.id=n,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const s=[];return e.children.forEach(function(n){const r=t[n.ID];if(r.attrType!=="Cluster")return;const i={ID:n.ID,indices:[],weights:[],transformLink:new Q().fromArray(r.TransformLink.a)};"Indexes"in r&&(i.indices=r.Indexes.a,i.weights=r.Weights.a),s.push(i)}),{rawBones:s,bones:[]}}parseMorphTargets(e,t){const s=[];for(let n=0;n<e.children.length;n++){const r=e.children[n],i=t[r.ID],a={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if(i.attrType!=="BlendShapeChannel")return;a.geoID=se.get(parseInt(r.ID)).children.filter(function(c){return c.relationship===void 0})[0].ID,s.push(a)}return s}parseScene(e,t,s){de=new Xe;const n=this.parseModels(e.skeletons,t,s),r=j.Objects.Model,i=this;n.forEach(function(c){const l=r[c.ID];i.setLookAtProperties(c,l),se.get(c.ID).parents.forEach(function(p){const d=n.get(p.ID);d!==void 0&&d.add(c)}),c.parent===null&&de.add(c)}),this.bindSkeleton(e.skeletons,t,n),this.addGlobalSceneSettings(),de.traverse(function(c){if(c.userData.transformData){c.parent&&(c.userData.transformData.parentMatrix=c.parent.matrix,c.userData.transformData.parentMatrixWorld=c.parent.matrixWorld);const l=On(c.userData.transformData);c.applyMatrix4(l),c.updateWorldMatrix()}});const a=new Ys().parse();de.children.length===1&&de.children[0].isGroup&&(de.children[0].animations=a,de=de.children[0]),de.animations=a}parseModels(e,t,s){const n=new Map,r=j.Objects.Model;for(const i in r){const a=parseInt(i),c=r[i],l=se.get(a);let h=this.buildSkeleton(l,e,a,c.attrName);if(!h){switch(c.attrType){case"Camera":h=this.createCamera(l);break;case"Light":h=this.createLight(l);break;case"Mesh":h=this.createMesh(l,t,s);break;case"NurbsCurve":h=this.createCurve(l,t);break;case"LimbNode":case"Root":h=new Pt;break;case"Null":default:h=new Xe;break}h.name=c.attrName?at.sanitizeNodeName(c.attrName):"",h.userData.originalName=c.attrName,h.ID=a}this.getTransformData(h,c),n.set(a,h)}return n}buildSkeleton(e,t,s,n){let r=null;return e.parents.forEach(function(i){for(const a in t){const c=t[a];c.rawBones.forEach(function(l,h){if(l.ID===i.ID){const p=r;r=new Pt,r.matrixWorld.copy(l.transformLink),r.name=n?at.sanitizeNodeName(n):"",r.userData.originalName=n,r.ID=s,c.bones[h]=r,p!==null&&r.add(p)}})}}),r}createCamera(e){let t,s;if(e.children.forEach(function(n){const r=j.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new ze;else{let n=0;s.CameraProjectionType!==void 0&&s.CameraProjectionType.value===1&&(n=1);let r=1;s.NearPlane!==void 0&&(r=s.NearPlane.value/1e3);let i=1e3;s.FarPlane!==void 0&&(i=s.FarPlane.value/1e3);let a=window.innerWidth,c=window.innerHeight;s.AspectWidth!==void 0&&s.AspectHeight!==void 0&&(a=s.AspectWidth.value,c=s.AspectHeight.value);const l=a/c;let h=45;s.FieldOfView!==void 0&&(h=s.FieldOfView.value);const p=s.FocalLength?s.FocalLength.value:null;switch(n){case 0:t=new En(h,l,r,i),p!==null&&t.setFocalLength(p);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),t=new ze;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+n+"."),t=new ze;break}}return t}createLight(e){let t,s;if(e.children.forEach(function(n){const r=j.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new ze;else{let n;s.LightType===void 0?n=0:n=s.LightType.value;let r=16777215;s.Color!==void 0&&(r=Se.colorSpaceToWorking(new ae().fromArray(s.Color.value),ne));let i=s.Intensity===void 0?1:s.Intensity.value/100;s.CastLightOnObject!==void 0&&s.CastLightOnObject.value===0&&(i=0);let a=0;s.FarAttenuationEnd!==void 0&&(s.EnableFarAttenuation!==void 0&&s.EnableFarAttenuation.value===0?a=0:a=s.FarAttenuationEnd.value);const c=1;switch(n){case 0:t=new Dt(r,i,a,c);break;case 1:t=new Sn(r,i);break;case 2:let l=Math.PI/3;s.InnerAngle!==void 0&&(l=pe.degToRad(s.InnerAngle.value));let h=0;s.OuterAngle!==void 0&&(h=pe.degToRad(s.OuterAngle.value),h=Math.max(h,1)),t=new xn(r,i,a,l,h,c);break;default:console.warn("THREE.FBXLoader: Unknown light type "+s.LightType.value+", defaulting to a PointLight."),t=new Dt(r,i);break}s.CastShadows!==void 0&&s.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,s){let n,r=null,i=null;const a=[];if(e.children.forEach(function(c){t.has(c.ID)&&(r=t.get(c.ID)),s.has(c.ID)&&a.push(s.get(c.ID))}),a.length>1?i=a:a.length>0?i=a[0]:(i=new Qe({name:Ne.DEFAULT_MATERIAL_NAME,color:13421772}),a.push(i)),"color"in r.attributes&&a.forEach(function(c){c.vertexColors=!0}),r.groups.length>0){let c=!1;for(let l=0,h=r.groups.length;l<h;l++){const p=r.groups[l];(p.materialIndex<0||p.materialIndex>=a.length)&&(p.materialIndex=a.length,c=!0)}if(c){const l=new Qe;a.push(l)}}return r.FBX_Deformer?(n=new An(r,i),n.normalizeSkinWeights()):n=new yt(r,i),n}createCurve(e,t){const s=e.children.reduce(function(r,i){return t.has(i.ID)&&(r=t.get(i.ID)),r},null),n=new st({name:Ne.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new In(s,n)}getTransformData(e,t){const s={};"InheritType"in t&&(s.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?s.eulerOrder=ct(t.RotationOrder.value):s.eulerOrder=ct(0),"Lcl_Translation"in t&&(s.translation=t.Lcl_Translation.value),"PreRotation"in t&&(s.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(s.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(s.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(s.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(s.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(s.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(s.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(s.rotationPivot=t.RotationPivot.value),e.userData.transformData=s}setLookAtProperties(e,t){"LookAtProperty"in t&&se.get(e.ID).children.forEach(function(n){if(n.relationship==="LookAtProperty"){const r=j.Objects.Model[n.ID];if("Lcl_Translation"in r){const i=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(i),de.add(e.target)):e.lookAt(new re().fromArray(i))}}})}bindSkeleton(e,t,s){const n=this.parsePoseNodes();for(const r in e){const i=e[r];se.get(parseInt(i.ID)).parents.forEach(function(c){if(t.has(c.ID)){const l=c.ID;se.get(l).parents.forEach(function(p){s.has(p.ID)&&s.get(p.ID).bind(new bn(i.bones),n[p.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in j.Objects){const t=j.Objects.Pose;for(const s in t)if(t[s].attrType==="BindPose"&&t[s].NbPoseNodes>0){const n=t[s].PoseNode;Array.isArray(n)?n.forEach(function(r){e[r.Node]=new Q().fromArray(r.Matrix.a)}):e[n.Node]=new Q().fromArray(n.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in j){if("AmbientColor"in j.GlobalSettings){const e=j.GlobalSettings.AmbientColor.value,t=e[0],s=e[1],n=e[2];if(t!==0||s!==0||n!==0){const r=new ae().setRGB(t,s,n,ne);de.add(new Es(r,1))}}"UnitScaleFactor"in j.GlobalSettings&&(de.userData.unitScaleFactor=j.GlobalSettings.UnitScaleFactor.value)}}}class Ws{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in j.Objects){const s=j.Objects.Geometry;for(const n in s){const r=se.get(parseInt(n)),i=this.parseGeometry(r,s[n],e);t.set(parseInt(n),i)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,s){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,s);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,s){const n=s.skeletons,r=[],i=e.parents.map(function(p){return j.Objects.Model[p.ID]});if(i.length===0)return;const a=e.children.reduce(function(p,d){return n[d.ID]!==void 0&&(p=n[d.ID]),p},null);e.children.forEach(function(p){s.morphTargets[p.ID]!==void 0&&r.push(s.morphTargets[p.ID])});const c=i[0],l={};"RotationOrder"in c&&(l.eulerOrder=ct(c.RotationOrder.value)),"InheritType"in c&&(l.inheritType=parseInt(c.InheritType.value)),"GeometricTranslation"in c&&(l.translation=c.GeometricTranslation.value),"GeometricRotation"in c&&(l.rotation=c.GeometricRotation.value),"GeometricScaling"in c&&(l.scale=c.GeometricScaling.value);const h=On(l);return this.genGeometry(t,a,r,h)}genGeometry(e,t,s,n){const r=new ke;e.attrName&&(r.name=e.attrName);const i=this.parseGeoNode(e,t),a=this.genBuffers(i),c=new xe(a.vertex,3);if(c.applyMatrix4(n),r.setAttribute("position",c),a.colors.length>0&&r.setAttribute("color",new xe(a.colors,3)),t&&(r.setAttribute("skinIndex",new xs(a.weightsIndices,4)),r.setAttribute("skinWeight",new xe(a.vertexWeights,4)),r.FBX_Deformer=t),a.normal.length>0){const l=new Ss().getNormalMatrix(n),h=new xe(a.normal,3);h.applyNormalMatrix(l),r.setAttribute("normal",h)}if(a.uvs.forEach(function(l,h){const p=h===0?"uv":`uv${h}`;r.setAttribute(p,new xe(a.uvs[h],2))}),i.material&&i.material.mappingType!=="AllSame"){let l=a.materialIndex[0],h=0;if(a.materialIndex.forEach(function(p,d){p!==l&&(r.addGroup(h,d-h,l),l=p,h=d)}),r.groups.length>0){const p=r.groups[r.groups.length-1],d=p.start+p.count;d!==a.materialIndex.length&&r.addGroup(d,a.materialIndex.length-d,l)}r.groups.length===0&&r.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(r,e,s,n),r}parseGeoNode(e,t){const s={};if(s.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],s.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&e.LayerElementColor[0].Colors&&(s.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(s.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(s.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){s.uv=[];let n=0;for(;e.LayerElementUV[n];)e.LayerElementUV[n].UV&&s.uv.push(this.parseUVs(e.LayerElementUV[n])),n++}return s.weightTable={},t!==null&&(s.skeleton=t,t.rawBones.forEach(function(n,r){n.indices.forEach(function(i,a){s.weightTable[i]===void 0&&(s.weightTable[i]=[]),s.weightTable[i].push({id:r,weight:n.weights[a]})})})),s}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let s=0,n=0,r=!1,i=[],a=[],c=[],l=[],h=[],p=[];const d=this;return e.vertexIndices.forEach(function(y,x){let I,w=!1;y<0&&(y=y^-1,w=!0);let L=[],k=[];if(i.push(y*3,y*3+1,y*3+2),e.color){const F=dt(x,s,y,e.color);c.push(F[0],F[1],F[2])}if(e.skeleton){if(e.weightTable[y]!==void 0&&e.weightTable[y].forEach(function(F){k.push(F.weight),L.push(F.id)}),k.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const F=[0,0,0,0],N=[0,0,0,0];k.forEach(function(K,H){let V=K,ee=L[H];N.forEach(function(fe,ue,ce){if(V>fe){ce[ue]=V,V=fe;const me=F[ue];F[ue]=ee,ee=me}})}),L=F,k=N}for(;k.length<4;)k.push(0),L.push(0);for(let F=0;F<4;++F)h.push(k[F]),p.push(L[F])}if(e.normal){const F=dt(x,s,y,e.normal);a.push(F[0],F[1],F[2])}e.material&&e.material.mappingType!=="AllSame"&&(I=dt(x,s,y,e.material)[0],I<0&&(d.negativeMaterialIndices=!0,I=0)),e.uv&&e.uv.forEach(function(F,N){const K=dt(x,s,y,F);l[N]===void 0&&(l[N]=[]),l[N].push(K[0]),l[N].push(K[1])}),n++,w&&(d.genFace(t,e,i,I,a,c,l,h,p,n),s++,n=0,i=[],a=[],c=[],l=[],h=[],p=[])}),t}getNormalNewell(e){const t=new re(0,0,0);for(let s=0;s<e.length;s++){const n=e[s],r=e[(s+1)%e.length];t.x+=(n.y-r.y)*(n.z+r.z),t.y+=(n.z-r.z)*(n.x+r.x),t.z+=(n.x-r.x)*(n.y+r.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),n=(Math.abs(t.z)>.5?new re(0,1,0):new re(0,0,1)).cross(t).normalize(),r=t.clone().cross(n).normalize();return{normal:t,tangent:n,bitangent:r}}flattenVertex(e,t,s){return new Gt(e.dot(t),e.dot(s))}genFace(e,t,s,n,r,i,a,c,l,h){let p;if(h>3){const d=[],y=t.baseVertexPositions||t.vertexPositions;for(let L=0;L<s.length;L+=3)d.push(new re(y[s[L]],y[s[L+1]],y[s[L+2]]));const{tangent:x,bitangent:I}=this.getNormalTangentAndBitangent(d),w=[];for(const L of d)w.push(this.flattenVertex(L,x,I));p=As.triangulateShape(w,[])}else p=[[0,1,2]];for(const[d,y,x]of p)e.vertex.push(t.vertexPositions[s[d*3]]),e.vertex.push(t.vertexPositions[s[d*3+1]]),e.vertex.push(t.vertexPositions[s[d*3+2]]),e.vertex.push(t.vertexPositions[s[y*3]]),e.vertex.push(t.vertexPositions[s[y*3+1]]),e.vertex.push(t.vertexPositions[s[y*3+2]]),e.vertex.push(t.vertexPositions[s[x*3]]),e.vertex.push(t.vertexPositions[s[x*3+1]]),e.vertex.push(t.vertexPositions[s[x*3+2]]),t.skeleton&&(e.vertexWeights.push(c[d*4]),e.vertexWeights.push(c[d*4+1]),e.vertexWeights.push(c[d*4+2]),e.vertexWeights.push(c[d*4+3]),e.vertexWeights.push(c[y*4]),e.vertexWeights.push(c[y*4+1]),e.vertexWeights.push(c[y*4+2]),e.vertexWeights.push(c[y*4+3]),e.vertexWeights.push(c[x*4]),e.vertexWeights.push(c[x*4+1]),e.vertexWeights.push(c[x*4+2]),e.vertexWeights.push(c[x*4+3]),e.weightsIndices.push(l[d*4]),e.weightsIndices.push(l[d*4+1]),e.weightsIndices.push(l[d*4+2]),e.weightsIndices.push(l[d*4+3]),e.weightsIndices.push(l[y*4]),e.weightsIndices.push(l[y*4+1]),e.weightsIndices.push(l[y*4+2]),e.weightsIndices.push(l[y*4+3]),e.weightsIndices.push(l[x*4]),e.weightsIndices.push(l[x*4+1]),e.weightsIndices.push(l[x*4+2]),e.weightsIndices.push(l[x*4+3])),t.color&&(e.colors.push(i[d*3]),e.colors.push(i[d*3+1]),e.colors.push(i[d*3+2]),e.colors.push(i[y*3]),e.colors.push(i[y*3+1]),e.colors.push(i[y*3+2]),e.colors.push(i[x*3]),e.colors.push(i[x*3+1]),e.colors.push(i[x*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(r[d*3]),e.normal.push(r[d*3+1]),e.normal.push(r[d*3+2]),e.normal.push(r[y*3]),e.normal.push(r[y*3+1]),e.normal.push(r[y*3+2]),e.normal.push(r[x*3]),e.normal.push(r[x*3+1]),e.normal.push(r[x*3+2])),t.uv&&t.uv.forEach(function(I,w){e.uvs[w]===void 0&&(e.uvs[w]=[]),e.uvs[w].push(a[w][d*2]),e.uvs[w].push(a[w][d*2+1]),e.uvs[w].push(a[w][y*2]),e.uvs[w].push(a[w][y*2+1]),e.uvs[w].push(a[w][x*2]),e.uvs[w].push(a[w][x*2+1])})}addMorphTargets(e,t,s,n){if(s.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;s.forEach(function(i){i.rawTargets.forEach(function(a){const c=j.Objects.Geometry[a.geoID];c!==void 0&&r.genMorphGeometry(e,t,c,n,a.name)})})}genMorphGeometry(e,t,s,n,r){const i=t.Vertices!==void 0?t.Vertices.a:[],a=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],c=s.Vertices!==void 0?s.Vertices.a:[],l=s.Indexes!==void 0?s.Indexes.a:[],h=e.attributes.position.count*3,p=new Float32Array(h);for(let I=0;I<l.length;I++){const w=l[I]*3;p[w]=c[I*3],p[w+1]=c[I*3+1],p[w+2]=c[I*3+2]}const d={vertexIndices:a,vertexPositions:p,baseVertexPositions:i},y=this.genBuffers(d),x=new xe(y.vertex,3);x.name=r||s.attrName,x.applyMatrix4(n),e.morphAttributes.position.push(x)}parseNormals(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Normals.a;let r=[];return s==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:r,mappingType:t,referenceType:s}}parseUVs(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.UV.a;let r=[];return s==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:n,indices:r,mappingType:t,referenceType:s}}parseVertexColors(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Colors.a;let r=[];s==="IndexToDirect"&&(r=e.ColorIndex.a);for(let i=0,a=new ae;i<n.length;i+=4)a.fromArray(n,i),Se.colorSpaceToWorking(a,ne),a.toArray(n,i);return{dataSize:4,buffer:n,indices:r,mappingType:t,referenceType:s}}parseMaterialIndices(e){const t=e.MappingInformationType,s=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:s};const n=e.Materials.a,r=[];for(let i=0;i<n.length;++i)r.push(i);return{dataSize:1,buffer:n,indices:r,mappingType:t,referenceType:s}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new ke;const s=t-1,n=e.KnotVector.a,r=[],i=e.Points.a;for(let p=0,d=i.length;p<d;p+=4)r.push(new Is().fromArray(i,p));let a,c;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){a=s,c=n.length-1-a;for(let p=0;p<s;++p)r.push(r[p])}const h=new zs(s,n,r,a,c).getPoints(r.length*12);return new ke().setFromPoints(h)}}class Ys{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const s in t){const n=t[s],r=this.addClip(n);e.push(r)}return e}parseClips(){if(j.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=j.Objects.AnimationCurveNode,t=new Map;for(const s in e){const n=e[s];if(n.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:n.id,attr:n.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=j.Objects.AnimationCurve;for(const s in t){const n={id:t[s].id,times:t[s].KeyTime.a.map(er),values:t[s].KeyValueFloat.a},r=se.get(n.id);if(r!==void 0){const i=r.parents[0].ID,a=r.parents[0].relationship;a.match(/X/)?e.get(i).curves.x=n:a.match(/Y/)?e.get(i).curves.y=n:a.match(/Z/)?e.get(i).curves.z=n:a.match(/DeformPercent/)&&e.has(i)&&(e.get(i).curves.morph=n)}}}parseAnimationLayers(e){const t=j.Objects.AnimationLayer,s=new Map;for(const n in t){const r=[],i=se.get(parseInt(n));i!==void 0&&(i.children.forEach(function(c,l){if(e.has(c.ID)){const h=e.get(c.ID);if(h.curves.x!==void 0||h.curves.y!==void 0||h.curves.z!==void 0){if(r[l]===void 0){const p=se.get(c.ID).parents.filter(function(d){return d.relationship!==void 0})[0].ID;if(p!==void 0){const d=j.Objects.Model[p.toString()];if(d===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",c);return}const y={modelName:d.attrName?at.sanitizeNodeName(d.attrName):"",ID:d.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};de.traverse(function(x){x.ID===d.id&&(y.transform=x.matrix,x.userData.transformData&&(y.eulerOrder=x.userData.transformData.eulerOrder))}),y.transform||(y.transform=new Q),"PreRotation"in d&&(y.preRotation=d.PreRotation.value),"PostRotation"in d&&(y.postRotation=d.PostRotation.value),r[l]=y}}r[l]&&(r[l][h.attr]=h)}else if(h.curves.morph!==void 0){if(r[l]===void 0){const p=se.get(c.ID).parents.filter(function(L){return L.relationship!==void 0})[0].ID,d=se.get(p).parents[0].ID,y=se.get(d).parents[0].ID,x=se.get(y).parents[0].ID,I=j.Objects.Model[x],w={modelName:I.attrName?at.sanitizeNodeName(I.attrName):"",morphName:j.Objects.Deformer[p].attrName};r[l]=w}r[l][h.attr]=h}}}),s.set(parseInt(n),r))}return s}parseAnimStacks(e){const t=j.Objects.AnimationStack,s={};for(const n in t){const r=se.get(parseInt(n)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=e.get(r[0].ID);s[n]={name:t[n].attrName,layer:i}}return s}addClip(e){let t=[];const s=this;return e.layer.forEach(function(n){t=t.concat(s.generateTracks(n))}),new Rn(e.name,-1,t)}generateTracks(e){const t=[];let s=new re,n=new re;if(e.transform&&e.transform.decompose(s,new Ie,n),s=s.toArray(),n=n.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.T.curves,s,"position");r!==void 0&&t.push(r)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);r!==void 0&&t.push(r)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,n,"scale");r!==void 0&&t.push(r)}if(e.DeformPercent!==void 0){const r=this.generateMorphTrack(e);r!==void 0&&t.push(r)}return t}generateVectorTrack(e,t,s,n){const r=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(r,t,s);return new kt(e+"."+n,r,i)}generateRotationTrack(e,t,s,n,r){let i,a;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const d=this.interpolateRotations(t.x,t.y,t.z,r);i=d[0],a=d[1]}const c=ct(0);s!==void 0&&(s=s.map(pe.degToRad),s.push(c),s=new De().fromArray(s),s=new Ie().setFromEuler(s)),n!==void 0&&(n=n.map(pe.degToRad),n.push(c),n=new De().fromArray(n),n=new Ie().setFromEuler(n).invert());const l=new Ie,h=new De,p=[];if(!a||!i)return new Tt(e+".quaternion",[0],[0]);for(let d=0;d<a.length;d+=3)h.set(a[d],a[d+1],a[d+2],r),l.setFromEuler(h),s!==void 0&&l.premultiply(s),n!==void 0&&l.multiply(n),d>2&&new Ie().fromArray(p,(d-3)/3*4).dot(l)<0&&l.set(-l.x,-l.y,-l.z,-l.w),l.toArray(p,d/3*4);return new Tt(e+".quaternion",i,p)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,s=t.values.map(function(r){return r/100}),n=de.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new Nt(e.modelName+".morphTargetInfluences["+n+"]",t.times,s)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(s,n){return s-n}),t.length>1){let s=1,n=t[0];for(let r=1;r<t.length;r++){const i=t[r];i!==n&&(t[s]=i,n=i,s++)}t=t.slice(0,s)}return t}getKeyframeTrackValues(e,t,s){const n=s,r=[];let i=-1,a=-1,c=-1;return e.forEach(function(l){if(t.x&&(i=t.x.times.indexOf(l)),t.y&&(a=t.y.times.indexOf(l)),t.z&&(c=t.z.times.indexOf(l)),i!==-1){const h=t.x.values[i];r.push(h),n[0]=h}else r.push(n[0]);if(a!==-1){const h=t.y.values[a];r.push(h),n[1]=h}else r.push(n[1]);if(c!==-1){const h=t.z.values[c];r.push(h),n[2]=h}else r.push(n[2])}),r}interpolateRotations(e,t,s,n){const r=[],i=[];r.push(e.times[0]),i.push(pe.degToRad(e.values[0])),i.push(pe.degToRad(t.values[0])),i.push(pe.degToRad(s.values[0]));for(let a=1;a<e.values.length;a++){const c=[e.values[a-1],t.values[a-1],s.values[a-1]];if(isNaN(c[0])||isNaN(c[1])||isNaN(c[2]))continue;const l=c.map(pe.degToRad),h=[e.values[a],t.values[a],s.values[a]];if(isNaN(h[0])||isNaN(h[1])||isNaN(h[2]))continue;const p=h.map(pe.degToRad),d=[h[0]-c[0],h[1]-c[1],h[2]-c[2]],y=[Math.abs(d[0]),Math.abs(d[1]),Math.abs(d[2])];if(y[0]>=180||y[1]>=180||y[2]>=180){const I=Math.max(...y)/180,w=new De(...l,n),L=new De(...p,n),k=new Ie().setFromEuler(w),F=new Ie().setFromEuler(L);k.dot(F)&&F.set(-F.x,-F.y,-F.z,-F.w);const N=e.times[a-1],K=e.times[a]-N,H=new Ie,V=new De;for(let ee=0;ee<1;ee+=1/I)H.copy(k.clone().slerp(F.clone(),ee)),r.push(N+ee*K),V.setFromQuaternion(H,n),i.push(V.x),i.push(V.y),i.push(V.z)}else r.push(e.times[a]),i.push(pe.degToRad(e.values[a])),i.push(pe.degToRad(t.values[a])),i.push(pe.degToRad(s.values[a]))}return[r,i]}}class qs{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new Cn,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,s=e.split(/[\r\n]+/);return s.forEach(function(n,r){const i=n.match(/^[\s\t]*;/),a=n.match(/^[\s\t]*$/);if(i||a)return;const c=n.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),l=n.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),h=n.match("^\\t{"+(t.currentIndent-1)+"}}");c?t.parseNodeBegin(n,c):l?t.parseNodeProperty(n,l,s[++r]):h?t.popStack():n.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(n)}),this.allNodes}parseNodeBegin(e,t){const s=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map(function(c){return c.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:s},i=this.parseNodeAttr(n),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(s,r):s in a?(s==="PoseNode"?a.PoseNode.push(r):a[s].id!==void 0&&(a[s]={},a[s][a[s].id]=a[s]),i.id!==""&&(a[s][i.id]=r)):typeof i.id=="number"?(a[s]={},a[s][i.id]=r):s!=="Properties70"&&(s==="PoseNode"?a[s]=[r]:a[s]=r),typeof i.id=="number"&&(r.id=i.id),i.name!==""&&(r.attrName=i.name),i.type!==""&&(r.attrType=i.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let s="",n="";return e.length>1&&(s=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:s,type:n}}parseNodeProperty(e,t,s){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();n==="Content"&&r===","&&(r=s.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if(i.name==="Properties70"){this.parseNodeSpecialProperty(e,n,r);return}if(n==="C"){const c=r.split(",").slice(1),l=parseInt(c[0]),h=parseInt(c[1]);let p=r.split(",").slice(3);p=p.map(function(d){return d.trim().replace(/^"/,"")}),n="connections",r=[l,h],nr(r,p),i[n]===void 0&&(i[n]=[])}n==="Node"&&(i.id=r),n in i&&Array.isArray(i[n])?i[n].push(r):n!=="a"?i[n]=r:i.a=r,this.setCurrentProp(i,n),n==="a"&&r.slice(-1)!==","&&(i.a=_t(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=_t(t.a))}parseNodeSpecialProperty(e,t,s){const n=s.split('",').map(function(h){return h.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=n[0],i=n[1],a=n[2],c=n[3];let l=n[4];switch(i){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":l=parseFloat(l);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":l=_t(l);break}this.getPrevNode()[r]={type:i,type2:a,flag:c,value:l},this.setCurrentProp(this.getPrevNode(),r)}}class $s{parse(e){const t=new an(e);t.skip(23);const s=t.getUint32();if(s<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+s);const n=new Cn;for(;!this.endOfContent(t);){const r=this.parseNode(t,s);r!==null&&n.add(r.name,r)}return n}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const s={},n=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const i=e.getUint8(),a=e.getString(i);if(n===0)return null;const c=[];for(let d=0;d<r;d++)c.push(this.parseProperty(e));const l=c.length>0?c[0]:"",h=c.length>1?c[1]:"",p=c.length>2?c[2]:"";for(s.singleProperty=r===1&&e.getOffset()===n;n>e.getOffset();){const d=this.parseNode(e,t);d!==null&&this.parseSubNode(a,s,d)}return s.propertyList=c,typeof l=="number"&&(s.id=l),h!==""&&(s.attrName=h),p!==""&&(s.attrType=p),a!==""&&(s.name=a),s}parseSubNode(e,t,s){if(s.singleProperty===!0){const n=s.propertyList[0];Array.isArray(n)?(t[s.name]=s,s.a=n):t[s.name]=n}else if(e==="Connections"&&s.name==="C"){const n=[];s.propertyList.forEach(function(r,i){i!==0&&n.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(n)}else if(s.name==="Properties70")Object.keys(s).forEach(function(r){t[r]=s[r]});else if(e==="Properties70"&&s.name==="P"){let n=s.propertyList[0],r=s.propertyList[1];const i=s.propertyList[2],a=s.propertyList[3];let c;n.indexOf("Lcl ")===0&&(n=n.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?c=[s.propertyList[4],s.propertyList[5],s.propertyList[6]]:c=s.propertyList[4],t[n]={type:r,type2:i,flag:a,value:c}}else t[s.name]===void 0?typeof s.id=="number"?(t[s.name]={},t[s.name][s.id]=s):t[s.name]=s:s.name==="PoseNode"?(Array.isArray(t[s.name])||(t[s.name]=[t[s.name]]),t[s.name].push(s)):t[s.name][s.id]===void 0&&(t[s.name][s.id]=s)}parseProperty(e){const t=e.getString(1);let s;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return s=e.getUint32(),e.getArrayBuffer(s);case"S":return s=e.getUint32(),e.getString(s);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),r=e.getUint32(),i=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}const a=tt(new Uint8Array(e.getArrayBuffer(i))),c=new an(a.buffer);switch(t){case"b":case"c":return c.getBooleanArray(n);case"d":return c.getFloat64Array(n);case"f":return c.getFloat32Array(n);case"i":return c.getInt32Array(n);case"l":return c.getInt64Array(n)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class an{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let s=0;s<e;s++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let s=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const n=s.indexOf(0);return n>=0&&(s=new Uint8Array(this.dv.buffer,t,n)),this._textDecoder.decode(s)}}class Cn{add(e,t){this[e]=t}}function Qs(T){const e="Kaydara FBX Binary  \0";return T.byteLength>=e.length&&e===Fn(T,0,e.length)}function Js(T){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function s(n){const r=T[n-1];return T=T.slice(t+n),t++,r}for(let n=0;n<e.length;++n)if(s(1)===e[n])return!1;return!0}function cn(T){const e=/FBXVersion: (\d+)/,t=T.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function er(T){return T/46186158e3}const tr=[];function dt(T,e,t,s){let n;switch(s.mappingType){case"ByPolygonVertex":n=T;break;case"ByPolygon":n=e;break;case"ByVertice":n=t;break;case"AllSame":n=s.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+s.mappingType)}s.referenceType==="IndexToDirect"&&(n=s.indices[n]);const r=n*s.dataSize,i=r+s.dataSize;return sr(tr,s.buffer,r,i)}const Rt=new De,je=new re;function On(T){const e=new Q,t=new Q,s=new Q,n=new Q,r=new Q,i=new Q,a=new Q,c=new Q,l=new Q,h=new Q,p=new Q,d=new Q,y=T.inheritType?T.inheritType:0;T.translation&&e.setPosition(je.fromArray(T.translation));const x=ct(0);if(T.preRotation){const ce=T.preRotation.map(pe.degToRad);ce.push(x),t.makeRotationFromEuler(Rt.fromArray(ce))}if(T.rotation){const ce=T.rotation.map(pe.degToRad);ce.push(T.eulerOrder||x),s.makeRotationFromEuler(Rt.fromArray(ce))}if(T.postRotation){const ce=T.postRotation.map(pe.degToRad);ce.push(x),n.makeRotationFromEuler(Rt.fromArray(ce)),n.invert()}T.scale&&r.scale(je.fromArray(T.scale)),T.scalingOffset&&a.setPosition(je.fromArray(T.scalingOffset)),T.scalingPivot&&i.setPosition(je.fromArray(T.scalingPivot)),T.rotationOffset&&c.setPosition(je.fromArray(T.rotationOffset)),T.rotationPivot&&l.setPosition(je.fromArray(T.rotationPivot)),T.parentMatrixWorld&&(p.copy(T.parentMatrix),h.copy(T.parentMatrixWorld));const I=t.clone().multiply(s).multiply(n),w=new Q;w.extractRotation(h);const L=new Q;L.copyPosition(h);const k=L.clone().invert().multiply(h),F=w.clone().invert().multiply(k),N=r,K=new Q;if(y===0)K.copy(w).multiply(I).multiply(F).multiply(N);else if(y===1)K.copy(w).multiply(F).multiply(I).multiply(N);else{const me=new Q().scale(new re().setFromMatrixScale(p)).clone().invert(),lt=F.clone().multiply(me);K.copy(w).multiply(I).multiply(lt).multiply(N)}const H=l.clone().invert(),V=i.clone().invert();let ee=e.clone().multiply(c).multiply(l).multiply(t).multiply(s).multiply(n).multiply(H).multiply(a).multiply(i).multiply(r).multiply(V);const fe=new Q().copyPosition(ee),ue=h.clone().multiply(fe);return d.copyPosition(ue),ee=d.clone().multiply(K),ee.premultiply(h.invert()),ee}function ct(T){T=T||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return T===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[T]}function _t(T){return T.split(",").map(function(t){return parseFloat(t)})}function Fn(T,e,t){return e===void 0&&(e=0),t===void 0&&(t=T.byteLength),new TextDecoder().decode(new Uint8Array(T,e,t))}function nr(T,e){for(let t=0,s=T.length,n=e.length;t<n;t++,s++)T[s]=e[t]}function sr(T,e,t,s){for(let n=t,r=0;n<s;n++,r++)T[r]=e[n];return T}const Qr=Object.freeze(Object.defineProperty({__proto__:null,FBXLoader:Ks},Symbol.toStringTag,{value:"Module"}));class Jr extends Ne{constructor(e){super(e)}load(e,t,s,n){const r=this,i=new Ue(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,function(a){const c=r.parse(JSON.parse(a));t&&t(c)},s,n)}parse(e){return new rr(e)}}class rr{constructor(e){this.isFont=!0,this.type="Font",this.data=e}generateShapes(e,t=100,s="ltr"){const n=[],r=ir(e,t,this.data,s);for(let i=0,a=r.length;i<a;i++)n.push(...r[i].toShapes());return n}}function ir(T,e,t,s){const n=Array.from(T),r=e/t.resolution,i=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*r,a=[];let c=0,l=0;(s=="rtl"||s=="tb")&&n.reverse();for(let h=0;h<n.length;h++){const p=n[h];if(p===`
`)c=0,l-=i;else{const d=or(p,r,c,l,t);s=="tb"?(c=0,l+=t.ascender*r):c+=d.offsetX,a.push(d.path)}}return a}function or(T,e,t,s,n){const r=n.glyphs[T]||n.glyphs["?"];if(!r){console.error('THREE.Font: character "'+T+'" does not exists in font family '+n.familyName+".");return}const i=new bs;let a,c,l,h,p,d,y,x;if(r.o){const I=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let w=0,L=I.length;w<L;)switch(I[w++]){case"m":a=I[w++]*e+t,c=I[w++]*e+s,i.moveTo(a,c);break;case"l":a=I[w++]*e+t,c=I[w++]*e+s,i.lineTo(a,c);break;case"q":l=I[w++]*e+t,h=I[w++]*e+s,p=I[w++]*e+t,d=I[w++]*e+s,i.quadraticCurveTo(p,d,l,h);break;case"b":l=I[w++]*e+t,h=I[w++]*e+s,p=I[w++]*e+t,d=I[w++]*e+s,y=I[w++]*e+t,x=I[w++]*e+s,i.bezierCurveTo(p,d,y,x,l,h);break}}return{offsetX:r.ha*e,path:i}}class ar extends Ne{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new pr(t)}),this.register(function(t){return new fr(t)}),this.register(function(t){return new Sr(t)}),this.register(function(t){return new Ar(t)}),this.register(function(t){return new Ir(t)}),this.register(function(t){return new mr(t)}),this.register(function(t){return new gr(t)}),this.register(function(t){return new yr(t)}),this.register(function(t){return new Tr(t)}),this.register(function(t){return new hr(t)}),this.register(function(t){return new wr(t)}),this.register(function(t){return new dr(t)}),this.register(function(t){return new xr(t)}),this.register(function(t){return new Er(t)}),this.register(function(t){return new lr(t)}),this.register(function(t){return new br(t)}),this.register(function(t){return new Rr(t)})}load(e,t,s,n){const r=this;let i;if(this.resourcePath!=="")i=this.resourcePath;else if(this.path!==""){const l=Ve.extractUrlBase(e);i=Ve.resolveURL(l,this.path)}else i=Ve.extractUrlBase(e);this.manager.itemStart(e);const a=function(l){n?n(l):console.error(l),r.manager.itemError(e),r.manager.itemEnd(e)},c=new Ue(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(l){try{r.parse(l,i,function(h){t(h),r.manager.itemEnd(e)},a)}catch(h){a(h)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let r;const i={},a={},c=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(c.decode(new Uint8Array(e,0,4))===Pn){try{i[z.KHR_BINARY_GLTF]=new _r(e)}catch(p){n&&n(p);return}r=JSON.parse(i[z.KHR_BINARY_GLTF].content)}else r=JSON.parse(c.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new Hr(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const p=this.pluginCallbacks[h](l);p.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[p.name]=p,i[p.name]=!0}if(r.extensionsUsed)for(let h=0;h<r.extensionsUsed.length;++h){const p=r.extensionsUsed[h],d=r.extensionsRequired||[];switch(p){case z.KHR_MATERIALS_UNLIT:i[p]=new ur;break;case z.KHR_DRACO_MESH_COMPRESSION:i[p]=new vr(r,this.dracoLoader);break;case z.KHR_TEXTURE_TRANSFORM:i[p]=new Lr;break;case z.KHR_MESH_QUANTIZATION:i[p]=new Mr;break;default:d.indexOf(p)>=0&&a[p]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+p+'".')}}l.setExtensions(i),l.setPlugins(a),l.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,r){s.parse(e,t,n,r)})}}function cr(){let T={};return{get:function(e){return T[e]},add:function(e,t){T[e]=t},remove:function(e){delete T[e]},removeAll:function(){T={}}}}const z={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class lr{constructor(e){this.parser=e,this.name=z.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const r=t[s];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const r=t.json,c=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let l;const h=new ae(16777215);c.color!==void 0&&h.setRGB(c.color[0],c.color[1],c.color[2],le);const p=c.range!==void 0?c.range:0;switch(c.type){case"directional":l=new Sn(h),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new Dt(h),l.distance=p;break;case"spot":l=new xn(h),l.distance=p,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,l.angle=c.spot.outerConeAngle,l.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return l.position.set(0,0,0),be(l,c),c.intensity!==void 0&&(l.intensity=c.intensity),l.name=t.createUniqueName(c.name||"light_"+e),n=Promise.resolve(l),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,r=s.json.nodes[e],a=(r.extensions&&r.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(c){return s._getNodeRef(t.cache,a,c)})}}class ur{constructor(){this.name=z.KHR_MATERIALS_UNLIT}getMaterialType(){return et}extendParams(e,t,s){const n=[];e.color=new ae(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const i=r.baseColorFactor;e.color.setRGB(i[0],i[1],i[2],le),e.opacity=i[3]}r.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",r.baseColorTexture,ne))}return Promise.all(n)}}class hr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class pr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];if(i.clearcoatFactor!==void 0&&(t.clearcoat=i.clearcoatFactor),i.clearcoatTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatMap",i.clearcoatTexture)),i.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=i.clearcoatRoughnessFactor),i.clearcoatRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",i.clearcoatRoughnessTexture)),i.clearcoatNormalTexture!==void 0&&(r.push(s.assignTexture(t,"clearcoatNormalMap",i.clearcoatNormalTexture)),i.clearcoatNormalTexture.scale!==void 0)){const a=i.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Gt(a,a)}return Promise.all(r)}}class fr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class dr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.iridescenceFactor!==void 0&&(t.iridescence=i.iridescenceFactor),i.iridescenceTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceMap",i.iridescenceTexture)),i.iridescenceIor!==void 0&&(t.iridescenceIOR=i.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),i.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=i.iridescenceThicknessMinimum),i.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=i.iridescenceThicknessMaximum),i.iridescenceThicknessTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceThicknessMap",i.iridescenceThicknessTexture)),Promise.all(r)}}class mr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new ae(0,0,0),t.sheenRoughness=0,t.sheen=1;const i=n.extensions[this.name];if(i.sheenColorFactor!==void 0){const a=i.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],le)}return i.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=i.sheenRoughnessFactor),i.sheenColorTexture!==void 0&&r.push(s.assignTexture(t,"sheenColorMap",i.sheenColorTexture,ne)),i.sheenRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"sheenRoughnessMap",i.sheenRoughnessTexture)),Promise.all(r)}}class gr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.transmissionFactor!==void 0&&(t.transmission=i.transmissionFactor),i.transmissionTexture!==void 0&&r.push(s.assignTexture(t,"transmissionMap",i.transmissionTexture)),Promise.all(r)}}class yr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.thickness=i.thicknessFactor!==void 0?i.thicknessFactor:0,i.thicknessTexture!==void 0&&r.push(s.assignTexture(t,"thicknessMap",i.thicknessTexture)),t.attenuationDistance=i.attenuationDistance||1/0;const a=i.attenuationColor||[1,1,1];return t.attenuationColor=new ae().setRGB(a[0],a[1],a[2],le),Promise.all(r)}}class Tr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class wr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.specularIntensity=i.specularFactor!==void 0?i.specularFactor:1,i.specularTexture!==void 0&&r.push(s.assignTexture(t,"specularIntensityMap",i.specularTexture));const a=i.specularColorFactor||[1,1,1];return t.specularColor=new ae().setRGB(a[0],a[1],a[2],le),i.specularColorTexture!==void 0&&r.push(s.assignTexture(t,"specularColorMap",i.specularColorTexture,ne)),Promise.all(r)}}class Er{constructor(e){this.parser=e,this.name=z.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return t.bumpScale=i.bumpFactor!==void 0?i.bumpFactor:1,i.bumpTexture!==void 0&&r.push(s.assignTexture(t,"bumpMap",i.bumpTexture)),Promise.all(r)}}class xr{constructor(e){this.parser=e,this.name=z.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.anisotropyStrength!==void 0&&(t.anisotropy=i.anisotropyStrength),i.anisotropyRotation!==void 0&&(t.anisotropyRotation=i.anisotropyRotation),i.anisotropyTexture!==void 0&&r.push(s.assignTexture(t,"anisotropyMap",i.anisotropyTexture)),Promise.all(r)}}class Sr{constructor(e){this.parser=e,this.name=z.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],i=t.options.ktx2Loader;if(!i){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,i)}}class Ar{constructor(e){this.parser=e,this.name=z.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],a=n.images[i.source];let c=s.textureLoader;if(a.uri){const l=s.options.manager.getHandler(a.uri);l!==null&&(c=l)}return s.loadTextureImage(e,i.source,c)}}class Ir{constructor(e){this.parser=e,this.name=z.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],a=n.images[i.source];let c=s.textureLoader;if(a.uri){const l=s.options.manager.getHandler(a.uri);l!==null&&(c=l)}return s.loadTextureImage(e,i.source,c)}}class br{constructor(e){this.name=z.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],r=this.parser.getDependency("buffer",n.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(a){const c=n.byteOffset||0,l=n.byteLength||0,h=n.count,p=n.byteStride,d=new Uint8Array(a,c,l);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(h,p,d,n.mode,n.filter).then(function(y){return y.buffer}):i.ready.then(function(){const y=new ArrayBuffer(h*p);return i.decodeGltfBuffer(new Uint8Array(y),h,p,d,n.mode,n.filter),y})})}else return null}}class Rr{constructor(e){this.name=z.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const l of n.primitives)if(l.mode!==Ee.TRIANGLES&&l.mode!==Ee.TRIANGLE_STRIP&&l.mode!==Ee.TRIANGLE_FAN&&l.mode!==void 0)return null;const i=s.extensions[this.name].attributes,a=[],c={};for(const l in i)a.push(this.parser.getDependency("accessor",i[l]).then(h=>(c[l]=h,c[l])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(l=>{const h=l.pop(),p=h.isGroup?h.children:[h],d=l[0].count,y=[];for(const x of p){const I=new Q,w=new re,L=new Ie,k=new re(1,1,1),F=new Rs(x.geometry,x.material,d);for(let N=0;N<d;N++)c.TRANSLATION&&w.fromBufferAttribute(c.TRANSLATION,N),c.ROTATION&&L.fromBufferAttribute(c.ROTATION,N),c.SCALE&&k.fromBufferAttribute(c.SCALE,N),F.setMatrixAt(N,I.compose(w,L,k));for(const N in c)if(N==="_COLOR_0"){const K=c[N];F.instanceColor=new _s(K.array,K.itemSize,K.normalized)}else N!=="TRANSLATION"&&N!=="ROTATION"&&N!=="SCALE"&&x.geometry.setAttribute(N,c[N]);ze.prototype.copy.call(F,x),this.parser.assignFinalMaterial(F),y.push(F)}return h.isGroup?(h.clear(),h.add(...y),h):y[0]}))}}const Pn="glTF",$e=12,ln={JSON:1313821514,BIN:5130562};class _r{constructor(e){this.name=z.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,$e),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Pn)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-$e,r=new DataView(e,$e);let i=0;for(;i<n;){const a=r.getUint32(i,!0);i+=4;const c=r.getUint32(i,!0);if(i+=4,c===ln.JSON){const l=new Uint8Array(e,$e+i,a);this.content=s.decode(l)}else if(c===ln.BIN){const l=$e+i;this.body=e.slice(l,l+a)}i+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class vr{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=z.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,i=e.extensions[this.name].attributes,a={},c={},l={};for(const h in i){const p=Bt[h]||h.toLowerCase();a[p]=i[h]}for(const h in e.attributes){const p=Bt[h]||h.toLowerCase();if(i[h]!==void 0){const d=s.accessors[e.attributes[h]],y=Ke[d.componentType];l[p]=y.name,c[p]=d.normalized===!0}}return t.getDependency("bufferView",r).then(function(h){return new Promise(function(p,d){n.decodeDracoFile(h,function(y){for(const x in y.attributes){const I=y.attributes[x],w=c[x];w!==void 0&&(I.normalized=w)}p(y)},a,l,le,d)})})}}class Lr{constructor(){this.name=z.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Mr{constructor(){this.name=z.KHR_MESH_QUANTIZATION}}class Dn extends Us{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let i=0;i!==n;i++)t[i]=s[r+i];return t}interpolate_(e,t,s,n){const r=this.resultBuffer,i=this.sampleValues,a=this.valueSize,c=a*2,l=a*3,h=n-t,p=(s-t)/h,d=p*p,y=d*p,x=e*l,I=x-l,w=-2*y+3*d,L=y-d,k=1-w,F=L-d+p;for(let N=0;N!==a;N++){const K=i[I+N+a],H=i[I+N+c]*h,V=i[x+N+a],ee=i[x+N]*h;r[N]=k*K+F*H+w*V+L*ee}return r}}const Cr=new Ie;class Or extends Dn{interpolate_(e,t,s,n){const r=super.interpolate_(e,t,s,n);return Cr.fromArray(r).normalize().toArray(r),r}}const Ee={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Ke={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},un={9728:vn,9729:it,9984:Cs,9985:Ms,9986:Ls,9987:_n},hn={33071:Ot,33648:Os,10497:ot},vt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Bt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Oe={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Fr={CUBICSPLINE:void 0,LINEAR:Mn,STEP:ks},Lt={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Pr(T){return T.DefaultMaterial===void 0&&(T.DefaultMaterial=new Ln({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Ns})),T.DefaultMaterial}function Pe(T,e,t){for(const s in t.extensions)T[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function be(T,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(T.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Dr(T,e,t){let s=!1,n=!1,r=!1;for(let l=0,h=e.length;l<h;l++){const p=e[l];if(p.POSITION!==void 0&&(s=!0),p.NORMAL!==void 0&&(n=!0),p.COLOR_0!==void 0&&(r=!0),s&&n&&r)break}if(!s&&!n&&!r)return Promise.resolve(T);const i=[],a=[],c=[];for(let l=0,h=e.length;l<h;l++){const p=e[l];if(s){const d=p.POSITION!==void 0?t.getDependency("accessor",p.POSITION):T.attributes.position;i.push(d)}if(n){const d=p.NORMAL!==void 0?t.getDependency("accessor",p.NORMAL):T.attributes.normal;a.push(d)}if(r){const d=p.COLOR_0!==void 0?t.getDependency("accessor",p.COLOR_0):T.attributes.color;c.push(d)}}return Promise.all([Promise.all(i),Promise.all(a),Promise.all(c)]).then(function(l){const h=l[0],p=l[1],d=l[2];return s&&(T.morphAttributes.position=h),n&&(T.morphAttributes.normal=p),r&&(T.morphAttributes.color=d),T.morphTargetsRelative=!0,T})}function kr(T,e){if(T.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)T.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(T.morphTargetInfluences.length===t.length){T.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)T.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Nr(T){let e;const t=T.extensions&&T.extensions[z.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Mt(t.attributes):e=T.indices+":"+Mt(T.attributes)+":"+T.mode,T.targets!==void 0)for(let s=0,n=T.targets.length;s<n;s++)e+=":"+Mt(T.targets[s]);return e}function Mt(T){let e="";const t=Object.keys(T).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+T[t[s]]+";";return e}function Ht(T){switch(T){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Ur(T){return T.search(/\.jpe?g($|\?)/i)>0||T.search(/^data\:image\/jpeg/)===0?"image/jpeg":T.search(/\.webp($|\?)/i)>0||T.search(/^data\:image\/webp/)===0?"image/webp":T.search(/\.ktx2($|\?)/i)>0||T.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const Br=new Q;class Hr{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new cr,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,r=!1,i=-1;if(typeof navigator<"u"){const a=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(a)===!0;const c=a.match(/Version\/(\d+)/);n=s&&c?parseInt(c[1],10):-1,r=a.indexOf("Firefox")>-1,i=r?a.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||s&&n<17||r&&i<98?this.textureLoader=new wn(this.options.manager):this.textureLoader=new vs(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Ue(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(i){return i._markDefs&&i._markDefs()}),Promise.all(this._invokeAll(function(i){return i.beforeRoot&&i.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(i){const a={scene:i[0][n.scene||0],scenes:i[0],animations:i[1],cameras:i[2],asset:n.asset,parser:s,userData:{}};return Pe(r,a,n),be(a,n),Promise.all(s._invokeAll(function(c){return c.afterRoot&&c.afterRoot(a)})).then(function(){for(const c of a.scenes)c.updateMatrixWorld();e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const i=t[n].joints;for(let a=0,c=i.length;a<c;a++)e[i[a]].isBone=!0}for(let n=0,r=e.length;n<r;n++){const i=e[n];i.mesh!==void 0&&(this._addNodeRef(this.meshCache,i.mesh),i.skin!==void 0&&(s[i.mesh].isSkinnedMesh=!0)),i.camera!==void 0&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),r=(i,a)=>{const c=this.associations.get(i);c!=null&&this.associations.set(a,c);for(const[l,h]of i.children.entries())r(h,a.children[l])};return r(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const r=e(t[n]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":n=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(r,i){return s.getDependency(e,i)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[z.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(r,i){s.load(Ve.resolveURL(t.uri,n.path),r,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,r=t.byteOffset||0;return s.slice(r,r+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const i=vt[n.type],a=Ke[n.componentType],c=n.normalized===!0,l=new a(n.count*i);return Promise.resolve(new nt(l,i,c))}const r=[];return n.bufferView!==void 0?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),n.sparse!==void 0&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then(function(i){const a=i[0],c=vt[n.type],l=Ke[n.componentType],h=l.BYTES_PER_ELEMENT,p=h*c,d=n.byteOffset||0,y=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,x=n.normalized===!0;let I,w;if(y&&y!==p){const L=Math.floor(d/y),k="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+L+":"+n.count;let F=t.cache.get(k);F||(I=new l(a,L*y,n.count*y/h),F=new yn(I,y/h),t.cache.add(k,F)),w=new Tn(F,c,d%y/h,x)}else a===null?I=new l(n.count*c):I=new l(a,d,n.count*c),w=new nt(I,c,x);if(n.sparse!==void 0){const L=vt.SCALAR,k=Ke[n.sparse.indices.componentType],F=n.sparse.indices.byteOffset||0,N=n.sparse.values.byteOffset||0,K=new k(i[1],F,n.sparse.count*L),H=new l(i[2],N,n.sparse.count*c);a!==null&&(w=new nt(w.array.slice(),w.itemSize,w.normalized)),w.normalized=!1;for(let V=0,ee=K.length;V<ee;V++){const fe=K[V];if(w.setX(fe,H[V*c]),c>=2&&w.setY(fe,H[V*c+1]),c>=3&&w.setZ(fe,H[V*c+2]),c>=4&&w.setW(fe,H[V*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}w.normalized=x}return w})}loadTexture(e){const t=this.json,s=this.options,r=t.textures[e].source,i=t.images[r];let a=this.textureLoader;if(i.uri){const c=s.manager.getHandler(i.uri);c!==null&&(a=c)}return this.loadTextureImage(e,r,a)}loadTextureImage(e,t,s){const n=this,r=this.json,i=r.textures[e],a=r.images[t],c=(a.uri||a.bufferView)+":"+i.sampler;if(this.textureCache[c])return this.textureCache[c];const l=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=i.name||a.name||"",h.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(h.name=a.uri);const d=(r.samplers||{})[i.sampler]||{};return h.magFilter=un[d.magFilter]||it,h.minFilter=un[d.minFilter]||_n,h.wrapS=hn[d.wrapS]||ot,h.wrapT=hn[d.wrapT]||ot,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==vn&&h.minFilter!==it,n.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[c]=l,l}loadImageSource(e,t){const s=this,n=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(p=>p.clone());const i=n.images[e],a=self.URL||self.webkitURL;let c=i.uri||"",l=!1;if(i.bufferView!==void 0)c=s.getDependency("bufferView",i.bufferView).then(function(p){l=!0;const d=new Blob([p],{type:i.mimeType});return c=a.createObjectURL(d),c});else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(c).then(function(p){return new Promise(function(d,y){let x=d;t.isImageBitmapLoader===!0&&(x=function(I){const w=new Ft(I);w.needsUpdate=!0,d(w)}),t.load(Ve.resolveURL(p,r.path),x,void 0,y)})}).then(function(p){return l===!0&&a.revokeObjectURL(c),be(p,i),p.userData.mimeType=i.mimeType||Ur(i.uri),p}).catch(function(p){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),p});return this.sourceCache[e]=h,h}assignTexture(e,t,s,n){const r=this;return this.getDependency("texture",s.index).then(function(i){if(!i)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(i=i.clone(),i.channel=s.texCoord),r.extensions[z.KHR_TEXTURE_TRANSFORM]){const a=s.extensions!==void 0?s.extensions[z.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const c=r.associations.get(i);i=r.extensions[z.KHR_TEXTURE_TRANSFORM].extendTexture(i,a),r.associations.set(i,c)}}return n!==void 0&&(i.colorSpace=n),e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,i=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let c=this.cache.get(a);c||(c=new Je,rt.prototype.copy.call(c,s),c.color.copy(s.color),c.map=s.map,c.sizeAttenuation=!1,this.cache.add(a,c)),s=c}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let c=this.cache.get(a);c||(c=new st,rt.prototype.copy.call(c,s),c.color.copy(s.color),c.map=s.map,this.cache.add(a,c)),s=c}if(n||r||i){let a="ClonedMaterial:"+s.uuid+":";n&&(a+="derivative-tangents:"),r&&(a+="vertex-colors:"),i&&(a+="flat-shading:");let c=this.cache.get(a);c||(c=s.clone(),r&&(c.vertexColors=!0),i&&(c.flatShading=!0),n&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(a,c),this.associations.set(c,this.associations.get(s))),s=c}e.material=s}getMaterialType(){return Ln}loadMaterial(e){const t=this,s=this.json,n=this.extensions,r=s.materials[e];let i;const a={},c=r.extensions||{},l=[];if(c[z.KHR_MATERIALS_UNLIT]){const p=n[z.KHR_MATERIALS_UNLIT];i=p.getMaterialType(),l.push(p.extendParams(a,r,t))}else{const p=r.pbrMetallicRoughness||{};if(a.color=new ae(1,1,1),a.opacity=1,Array.isArray(p.baseColorFactor)){const d=p.baseColorFactor;a.color.setRGB(d[0],d[1],d[2],le),a.opacity=d[3]}p.baseColorTexture!==void 0&&l.push(t.assignTexture(a,"map",p.baseColorTexture,ne)),a.metalness=p.metallicFactor!==void 0?p.metallicFactor:1,a.roughness=p.roughnessFactor!==void 0?p.roughnessFactor:1,p.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(a,"metalnessMap",p.metallicRoughnessTexture)),l.push(t.assignTexture(a,"roughnessMap",p.metallicRoughnessTexture))),i=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}r.doubleSided===!0&&(a.side=Fs);const h=r.alphaMode||Lt.OPAQUE;if(h===Lt.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,h===Lt.MASK&&(a.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&i!==et&&(l.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new Gt(1,1),r.normalTexture.scale!==void 0)){const p=r.normalTexture.scale;a.normalScale.set(p,p)}if(r.occlusionTexture!==void 0&&i!==et&&(l.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&i!==et){const p=r.emissiveFactor;a.emissive=new ae().setRGB(p[0],p[1],p[2],le)}return r.emissiveTexture!==void 0&&i!==et&&l.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,ne)),Promise.all(l).then(function(){const p=new i(a);return r.name&&(p.name=r.name),be(p,r),t.associations.set(p,{materials:e}),r.extensions&&Pe(n,p,r),p})}createUniqueName(e){const t=at.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function r(a){return s[z.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(c){return pn(c,a,t)})}const i=[];for(let a=0,c=e.length;a<c;a++){const l=e[a],h=Nr(l),p=n[h];if(p)i.push(p.promise);else{let d;l.extensions&&l.extensions[z.KHR_DRACO_MESH_COMPRESSION]?d=r(l):d=pn(new ke,l,t),n[h]={primitive:l,promise:d},i.push(d)}}return Promise.all(i)}loadMesh(e){const t=this,s=this.json,n=this.extensions,r=s.meshes[e],i=r.primitives,a=[];for(let c=0,l=i.length;c<l;c++){const h=i[c].material===void 0?Pr(this.cache):this.getDependency("material",i[c].material);a.push(h)}return a.push(t.loadGeometries(i)),Promise.all(a).then(function(c){const l=c.slice(0,c.length-1),h=c[c.length-1],p=[];for(let y=0,x=h.length;y<x;y++){const I=h[y],w=i[y];let L;const k=l[y];if(w.mode===Ee.TRIANGLES||w.mode===Ee.TRIANGLE_STRIP||w.mode===Ee.TRIANGLE_FAN||w.mode===void 0)L=r.isSkinnedMesh===!0?new An(I,k):new yt(I,k),L.isSkinnedMesh===!0&&L.normalizeSkinWeights(),w.mode===Ee.TRIANGLE_STRIP?L.geometry=on(L.geometry,Gs):w.mode===Ee.TRIANGLE_FAN&&(L.geometry=on(L.geometry,js));else if(w.mode===Ee.LINES)L=new Ut(I,k);else if(w.mode===Ee.LINE_STRIP)L=new In(I,k);else if(w.mode===Ee.LINE_LOOP)L=new Ps(I,k);else if(w.mode===Ee.POINTS)L=new gt(I,k);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+w.mode);Object.keys(L.geometry.morphAttributes).length>0&&kr(L,r),L.name=t.createUniqueName(r.name||"mesh_"+e),be(L,r),w.extensions&&Pe(n,L,w),t.assignFinalMaterial(L),p.push(L)}for(let y=0,x=p.length;y<x;y++)t.associations.set(p[y],{meshes:e,primitives:y});if(p.length===1)return r.extensions&&Pe(n,p[0],r),p[0];const d=new Xe;r.extensions&&Pe(n,d,r),t.associations.set(d,{meshes:e});for(let y=0,x=p.length;y<x;y++)d.add(p[y]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new En(pe.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new Ds(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),be(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,r=t.joints.length;n<r;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const r=n.pop(),i=n,a=[],c=[];for(let l=0,h=i.length;l<h;l++){const p=i[l];if(p){a.push(p);const d=new Q;r!==null&&d.fromArray(r.array,l*16),c.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[l])}return new bn(a,c)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],r=n.name?n.name:"animation_"+e,i=[],a=[],c=[],l=[],h=[];for(let p=0,d=n.channels.length;p<d;p++){const y=n.channels[p],x=n.samplers[y.sampler],I=y.target,w=I.node,L=n.parameters!==void 0?n.parameters[x.input]:x.input,k=n.parameters!==void 0?n.parameters[x.output]:x.output;I.node!==void 0&&(i.push(this.getDependency("node",w)),a.push(this.getDependency("accessor",L)),c.push(this.getDependency("accessor",k)),l.push(x),h.push(I))}return Promise.all([Promise.all(i),Promise.all(a),Promise.all(c),Promise.all(l),Promise.all(h)]).then(function(p){const d=p[0],y=p[1],x=p[2],I=p[3],w=p[4],L=[];for(let F=0,N=d.length;F<N;F++){const K=d[F],H=y[F],V=x[F],ee=I[F],fe=w[F];if(K===void 0)continue;K.updateMatrix&&K.updateMatrix();const ue=s._createAnimationTracks(K,H,V,ee,fe);if(ue)for(let ce=0;ce<ue.length;ce++)L.push(ue[ce])}const k=new Rn(r,void 0,L);return be(k,n),k})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(r){const i=s._getNodeRef(s.meshCache,n.mesh,r);return n.weights!==void 0&&i.traverse(function(a){if(a.isMesh)for(let c=0,l=n.weights.length;c<l;c++)a.morphTargetInfluences[c]=n.weights[c]}),i})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],r=s._loadNodeShallow(e),i=[],a=n.children||[];for(let l=0,h=a.length;l<h;l++)i.push(s.getDependency("node",a[l]));const c=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([r,Promise.all(i),c]).then(function(l){const h=l[0],p=l[1],d=l[2];d!==null&&h.traverse(function(y){y.isSkinnedMesh&&y.bind(d,Br)});for(let y=0,x=p.length;y<x;y++)h.add(p[y]);return h})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],i=r.name?n.createUniqueName(r.name):"",a=[],c=n._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return c&&a.push(c),r.camera!==void 0&&a.push(n.getDependency("camera",r.camera).then(function(l){return n._getNodeRef(n.cameraCache,r.camera,l)})),n._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){a.push(l)}),this.nodeCache[e]=Promise.all(a).then(function(l){let h;if(r.isBone===!0?h=new Pt:l.length>1?h=new Xe:l.length===1?h=l[0]:h=new ze,h!==l[0])for(let p=0,d=l.length;p<d;p++)h.add(l[p]);if(r.name&&(h.userData.name=r.name,h.name=i),be(h,r),r.extensions&&Pe(s,h,r),r.matrix!==void 0){const p=new Q;p.fromArray(r.matrix),h.applyMatrix4(p)}else r.translation!==void 0&&h.position.fromArray(r.translation),r.rotation!==void 0&&h.quaternion.fromArray(r.rotation),r.scale!==void 0&&h.scale.fromArray(r.scale);if(!n.associations.has(h))n.associations.set(h,{});else if(r.mesh!==void 0&&n.meshCache.refs[r.mesh]>1){const p=n.associations.get(h);n.associations.set(h,{...p})}return n.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,r=new Xe;s.name&&(r.name=n.createUniqueName(s.name)),be(r,s),s.extensions&&Pe(t,r,s);const i=s.nodes||[],a=[];for(let c=0,l=i.length;c<l;c++)a.push(n.getDependency("node",i[c]));return Promise.all(a).then(function(c){for(let h=0,p=c.length;h<p;h++)r.add(c[h]);const l=h=>{const p=new Map;for(const[d,y]of n.associations)(d instanceof rt||d instanceof Ft)&&p.set(d,y);return h.traverse(d=>{const y=n.associations.get(d);y!=null&&p.set(d,y)}),p};return n.associations=l(r),r})}_createAnimationTracks(e,t,s,n,r){const i=[],a=e.name?e.name:e.uuid,c=[];Oe[r.path]===Oe.weights?e.traverse(function(d){d.morphTargetInfluences&&c.push(d.name?d.name:d.uuid)}):c.push(a);let l;switch(Oe[r.path]){case Oe.weights:l=Nt;break;case Oe.rotation:l=Tt;break;case Oe.translation:case Oe.scale:l=kt;break;default:switch(s.itemSize){case 1:l=Nt;break;case 2:case 3:default:l=kt;break}break}const h=n.interpolation!==void 0?Fr[n.interpolation]:Mn,p=this._getArrayFromAccessor(s);for(let d=0,y=c.length;d<y;d++){const x=new l(c[d]+"."+Oe[r.path],t.array,p,h);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(x),i.push(x)}return i}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=Ht(t.constructor),n=new Float32Array(t.length);for(let r=0,i=t.length;r<i;r++)n[r]=t[r]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof Tt?Or:Dn;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Gr(T,e,t){const s=e.attributes,n=new Bs;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],c=a.min,l=a.max;if(c!==void 0&&l!==void 0){if(n.set(new re(c[0],c[1],c[2]),new re(l[0],l[1],l[2])),a.normalized){const h=Ht(Ke[a.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const a=new re,c=new re;for(let l=0,h=r.length;l<h;l++){const p=r[l];if(p.POSITION!==void 0){const d=t.json.accessors[p.POSITION],y=d.min,x=d.max;if(y!==void 0&&x!==void 0){if(c.setX(Math.max(Math.abs(y[0]),Math.abs(x[0]))),c.setY(Math.max(Math.abs(y[1]),Math.abs(x[1]))),c.setZ(Math.max(Math.abs(y[2]),Math.abs(x[2]))),d.normalized){const I=Ht(Ke[d.componentType]);c.multiplyScalar(I)}a.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(a)}T.boundingBox=n;const i=new Hs;n.getCenter(i.center),i.radius=n.min.distanceTo(n.max)/2,T.boundingSphere=i}function pn(T,e,t){const s=e.attributes,n=[];function r(i,a){return t.getDependency("accessor",i).then(function(c){T.setAttribute(a,c)})}for(const i in s){const a=Bt[i]||i.toLowerCase();a in T.attributes||n.push(r(s[i],a))}if(e.indices!==void 0&&!T.index){const i=t.getDependency("accessor",e.indices).then(function(a){T.setIndex(a)});n.push(i)}return Se.workingColorSpace!==le&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Se.workingColorSpace}" not supported.`),be(T,e),Gr(T,e,t),Promise.all(n).then(function(){return e.targets!==void 0?Dr(T,e.targets,t):T})}const ei=Object.freeze(Object.defineProperty({__proto__:null,GLTFLoader:ar},Symbol.toStringTag,{value:"Module"})),jr=/^[og]\s*(.+)?/,zr=/^mtllib /,Vr=/^usemtl /,Xr=/^usemap /,fn=/\s+/,dn=new re,Ct=new re,mn=new re,gn=new re,we=new re,mt=new ae;function Kr(){const T={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=e,this.object.fromDeclaration=t!==!1;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(n,r){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const a={index:this.materials.length,name:n||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:i!==void 0?i.smooth:this.smooth,groupStart:i!==void 0?i.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(c){const l={index:typeof c=="number"?c:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return l.clone=this.clone.bind(l),l}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(n){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),n&&this.materials.length>1)for(let i=this.materials.length-1;i>=0;i--)this.materials[i].groupCount<=0&&this.materials.splice(i,1);return n&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},s&&s.name&&typeof s.clone=="function"){const n=s.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/3)*3},parseNormalIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/3)*3},parseUVIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/2)*2},addVertex:function(e,t,s){const n=this.vertices,r=this.object.geometry.vertices;r.push(n[e+0],n[e+1],n[e+2]),r.push(n[t+0],n[t+1],n[t+2]),r.push(n[s+0],n[s+1],n[s+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,s){const n=this.normals,r=this.object.geometry.normals;r.push(n[e+0],n[e+1],n[e+2]),r.push(n[t+0],n[t+1],n[t+2]),r.push(n[s+0],n[s+1],n[s+2])},addFaceNormal:function(e,t,s){const n=this.vertices,r=this.object.geometry.normals;dn.fromArray(n,e),Ct.fromArray(n,t),mn.fromArray(n,s),we.subVectors(mn,Ct),gn.subVectors(dn,Ct),we.cross(gn),we.normalize(),r.push(we.x,we.y,we.z),r.push(we.x,we.y,we.z),r.push(we.x,we.y,we.z)},addColor:function(e,t,s){const n=this.colors,r=this.object.geometry.colors;n[e]!==void 0&&r.push(n[e+0],n[e+1],n[e+2]),n[t]!==void 0&&r.push(n[t+0],n[t+1],n[t+2]),n[s]!==void 0&&r.push(n[s+0],n[s+1],n[s+2])},addUV:function(e,t,s){const n=this.uvs,r=this.object.geometry.uvs;r.push(n[e+0],n[e+1]),r.push(n[t+0],n[t+1]),r.push(n[s+0],n[s+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,s,n,r,i,a,c,l){const h=this.vertices.length;let p=this.parseVertexIndex(e,h),d=this.parseVertexIndex(t,h),y=this.parseVertexIndex(s,h);if(this.addVertex(p,d,y),this.addColor(p,d,y),a!==void 0&&a!==""){const x=this.normals.length;p=this.parseNormalIndex(a,x),d=this.parseNormalIndex(c,x),y=this.parseNormalIndex(l,x),this.addNormal(p,d,y)}else this.addFaceNormal(p,d,y);if(n!==void 0&&n!==""){const x=this.uvs.length;p=this.parseUVIndex(n,x),d=this.parseUVIndex(r,x),y=this.parseUVIndex(i,x),this.addUV(p,d,y),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let s=0,n=e.length;s<n;s++){const r=this.parseVertexIndex(e[s],t);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const s=this.vertices.length,n=this.uvs.length;for(let r=0,i=e.length;r<i;r++)this.addVertexLine(this.parseVertexIndex(e[r],s));for(let r=0,i=t.length;r<i;r++)this.addUVLine(this.parseUVIndex(t[r],n))}};return T.startObject("",!1),T}class Zr extends Ne{constructor(e){super(e),this.materials=null}load(e,t,s,n){const r=this,i=new Ue(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,function(a){try{t(r.parse(a))}catch(c){n?n(c):console.error(c),r.manager.itemError(e)}},s,n)}setMaterials(e){return this.materials=e,this}parse(e){const t=new Kr;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const s=e.split(`
`);let n=[];for(let a=0,c=s.length;a<c;a++){const l=s[a].trimStart();if(l.length===0)continue;const h=l.charAt(0);if(h!=="#")if(h==="v"){const p=l.split(fn);switch(p[0]){case"v":t.vertices.push(parseFloat(p[1]),parseFloat(p[2]),parseFloat(p[3])),p.length>=7?(mt.setRGB(parseFloat(p[4]),parseFloat(p[5]),parseFloat(p[6]),ne),t.colors.push(mt.r,mt.g,mt.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(p[1]),parseFloat(p[2]),parseFloat(p[3]));break;case"vt":t.uvs.push(parseFloat(p[1]),parseFloat(p[2]));break}}else if(h==="f"){const d=l.slice(1).trim().split(fn),y=[];for(let I=0,w=d.length;I<w;I++){const L=d[I];if(L.length>0){const k=L.split("/");y.push(k)}}const x=y[0];for(let I=1,w=y.length-1;I<w;I++){const L=y[I],k=y[I+1];t.addFace(x[0],L[0],k[0],x[1],L[1],k[1],x[2],L[2],k[2])}}else if(h==="l"){const p=l.substring(1).trim().split(" ");let d=[];const y=[];if(l.indexOf("/")===-1)d=p;else for(let x=0,I=p.length;x<I;x++){const w=p[x].split("/");w[0]!==""&&d.push(w[0]),w[1]!==""&&y.push(w[1])}t.addLineGeometry(d,y)}else if(h==="p"){const d=l.slice(1).trim().split(" ");t.addPointGeometry(d)}else if((n=jr.exec(l))!==null){const p=(" "+n[0].slice(1).trim()).slice(1);t.startObject(p)}else if(Vr.test(l))t.object.startMaterial(l.substring(7).trim(),t.materialLibraries);else if(zr.test(l))t.materialLibraries.push(l.substring(7).trim());else if(Xr.test(l))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(h==="s"){if(n=l.split(" "),n.length>1){const d=n[1].trim().toLowerCase();t.object.smooth=d!=="0"&&d!=="off"}else t.object.smooth=!0;const p=t.object.currentMaterial();p&&(p.smooth=t.object.smooth)}else{if(l==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+l+'"')}}t.finalize();const r=new Xe;if(r.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let a=0,c=t.objects.length;a<c;a++){const l=t.objects[a],h=l.geometry,p=l.materials,d=h.type==="Line",y=h.type==="Points";let x=!1;if(h.vertices.length===0)continue;const I=new ke;I.setAttribute("position",new xe(h.vertices,3)),h.normals.length>0&&I.setAttribute("normal",new xe(h.normals,3)),h.colors.length>0&&(x=!0,I.setAttribute("color",new xe(h.colors,3))),h.hasUVIndices===!0&&I.setAttribute("uv",new xe(h.uvs,2));const w=[];for(let k=0,F=p.length;k<F;k++){const N=p[k],K=N.name+"_"+N.smooth+"_"+x;let H=t.materials[K];if(this.materials!==null){if(H=this.materials.create(N.name),d&&H&&!(H instanceof st)){const V=new st;rt.prototype.copy.call(V,H),V.color.copy(H.color),H=V}else if(y&&H&&!(H instanceof Je)){const V=new Je({size:10,sizeAttenuation:!1});rt.prototype.copy.call(V,H),V.color.copy(H.color),V.map=H.map,H=V}}H===void 0&&(d?H=new st:y?H=new Je({size:1,sizeAttenuation:!1}):H=new Qe,H.name=N.name,H.flatShading=!N.smooth,H.vertexColors=x,t.materials[K]=H),w.push(H)}let L;if(w.length>1){for(let k=0,F=p.length;k<F;k++){const N=p[k];I.addGroup(N.groupStart,N.groupCount,k)}d?L=new Ut(I,w):y?L=new gt(I,w):L=new yt(I,w)}else d?L=new Ut(I,w[0]):y?L=new gt(I,w[0]):L=new yt(I,w[0]);L.name=l.name,r.add(L)}else if(t.vertices.length>0){const a=new Je({size:1,sizeAttenuation:!1}),c=new ke;c.setAttribute("position",new xe(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(c.setAttribute("color",new xe(t.colors,3)),a.vertexColors=!0);const l=new gt(c,a);r.add(l)}return r}}const ti=Object.freeze(Object.defineProperty({__proto__:null,OBJLoader:Zr},Symbol.toStringTag,{value:"Module"}));export{Vs as D,qr as E,Ks as F,ar as G,Zr as O,Jr as a,rr as b,$r as c,Qr as d,ei as e,ti as f};
