import{D as ms,H as pt,R as Be,a as qe,L as le,b as ft,F as It,c as it,d as rn,e as Xe,f as Ke,S as te,B as ke,g as nt,C as ae,h as Ae,i as je,T as yn,j as ot,k as Ot,l as Ft,M as Qe,m as gs,E as ys,n as Q,G as Ve,o as Dt,P as at,O as Ge,p as Tn,q as Pt,r as he,s as wn,t as En,u as xn,v as yt,w as st,x as An,V as se,y as Sn,A as Ts,z as Ee,U as ws,I as Es,J as Gt,K as xs,N as As,Q as Pe,W as In,X as Ie,Y as kt,Z as Tt,_ as Nt,$ as be,a0 as Ss,a1 as Is,a2 as Rs,a3 as bs,a4 as Rn,a5 as vs,a6 as _s,a7 as Ls,a8 as bn,a9 as Ms,aa as Je,ab as rt,ac as vn,ad as Cs,ae as et,af as Ut,ag as Os,ah as gt,ai as Fs,aj as Ds,ak as _n,al as Ps,am as ks,an as Ns,ao as Us,ap as Bs,aq as Hs,ar as Gs}from"./three-CReAsTRh.js";import{u as tt,N as js,t as on}from"./index-DfqgG6vJ.js";class Kr extends ms{constructor(e){super(e),this.type=pt,this.outputFormat=Be}parse(e){const fe=Math.pow(2.7182818,2.2);function xe(o,l){let f=0;for(let w=0;w<65536;++w)(w==0||o[w>>3]&1<<(w&7))&&(l[f++]=w);const g=f-1;for(;f<65536;)l[f++]=0;return g}function ce(o){for(let l=0;l<16384;l++)o[l]={},o[l].len=0,o[l].lit=0,o[l].p=null}const de={l:0,c:0,lc:0};function lt(o,l,f,g,w){for(;f<o;)l=l<<8|en(g,w),f+=8;f-=o,de.l=l>>f&(1<<o)-1,de.c=l,de.lc=f}const Ze=new Array(59);function Dn(o){for(let f=0;f<=58;++f)Ze[f]=0;for(let f=0;f<65537;++f)Ze[o[f]]+=1;let l=0;for(let f=58;f>0;--f){const g=l+Ze[f]>>1;Ze[f]=l,l=g}for(let f=0;f<65537;++f){const g=o[f];g>0&&(o[f]=g|Ze[g]++<<6)}}function Pn(o,l,f,g,w,R){const m=l;let b=0,A=0;for(;g<=w;g++){if(m.value-l.value>f)return!1;lt(6,b,A,o,m);const x=de.l;if(b=de.c,A=de.lc,R[g]=x,x==63){if(m.value-l.value>f)throw new Error("Something wrong with hufUnpackEncTable");lt(8,b,A,o,m);let I=de.l+6;if(b=de.c,A=de.lc,g+I>w+1)throw new Error("Something wrong with hufUnpackEncTable");for(;I--;)R[g++]=0;g--}else if(x>=59){let I=x-59+2;if(g+I>w+1)throw new Error("Something wrong with hufUnpackEncTable");for(;I--;)R[g++]=0;g--}}Dn(R)}function jt(o){return o&63}function Vt(o){return o>>6}function kn(o,l,f,g){for(;l<=f;l++){const w=Vt(o[l]),R=jt(o[l]);if(w>>R)throw new Error("Invalid table entry");if(R>14){const m=g[w>>R-14];if(m.len)throw new Error("Invalid table entry");if(m.lit++,m.p){const b=m.p;m.p=new Array(m.lit);for(let A=0;A<m.lit-1;++A)m.p[A]=b[A]}else m.p=new Array(1);m.p[m.lit-1]=l}else if(R){let m=0;for(let b=1<<14-R;b>0;b--){const A=g[(w<<14-R)+m];if(A.len||A.p)throw new Error("Invalid table entry");A.len=R,A.lit=l,m++}}}return!0}const _e={c:0,lc:0};function wt(o,l,f,g){o=o<<8|en(f,g),l+=8,_e.c=o,_e.lc=l}const Le={c:0,lc:0};function Et(o,l,f,g,w,R,m,b,A){if(o==l){g<8&&(wt(f,g,w,R),f=_e.c,g=_e.lc),g-=8;let x=f>>g;if(x=new Uint8Array([x])[0],b.value+x>A)return!1;const I=m[b.value-1];for(;x-- >0;)m[b.value++]=I}else if(b.value<A)m[b.value++]=o;else return!1;Le.c=f,Le.lc=g}function xt(o){return o&65535}function zt(o){const l=xt(o);return l>32767?l-65536:l}const J={a:0,b:0};function Ne(o,l){const f=zt(o),w=zt(l),R=f+(w&1)+(w>>1),m=R,b=R-w;J.a=m,J.b=b}function Ue(o,l){const f=xt(o),g=xt(l),w=f-(g>>1)&65535,R=g+w-32768&65535;J.a=R,J.b=w}function Nn(o,l,f,g,w,R,m){const b=m<16384,A=f>w?w:f;let x=1,I,M;for(;x<=A;)x<<=1;for(x>>=1,I=x,x>>=1;x>=1;){M=0;const _=M+R*(w-I),O=R*x,N=R*I,C=g*x,P=g*I;let B,X,Y,ie;for(;M<=_;M+=N){let W=M;const H=M+g*(f-I);for(;W<=H;W+=P){const ee=W+C,oe=W+O,$=oe+C;b?(Ne(o[W+l],o[oe+l]),B=J.a,Y=J.b,Ne(o[ee+l],o[$+l]),X=J.a,ie=J.b,Ne(B,X),o[W+l]=J.a,o[ee+l]=J.b,Ne(Y,ie),o[oe+l]=J.a,o[$+l]=J.b):(Ue(o[W+l],o[oe+l]),B=J.a,Y=J.b,Ue(o[ee+l],o[$+l]),X=J.a,ie=J.b,Ue(B,X),o[W+l]=J.a,o[ee+l]=J.b,Ue(Y,ie),o[oe+l]=J.a,o[$+l]=J.b)}if(f&x){const ee=W+O;b?Ne(o[W+l],o[ee+l]):Ue(o[W+l],o[ee+l]),B=J.a,o[ee+l]=J.b,o[W+l]=B}}if(w&x){let W=M;const H=M+g*(f-I);for(;W<=H;W+=P){const ee=W+C;b?Ne(o[W+l],o[ee+l]):Ue(o[W+l],o[ee+l]),B=J.a,o[ee+l]=J.b,o[W+l]=B}}I=x,x>>=1}return M}function Un(o,l,f,g,w,R,m,b,A){let x=0,I=0;const M=m,_=Math.trunc(g.value+(w+7)/8);for(;g.value<_;)for(wt(x,I,f,g),x=_e.c,I=_e.lc;I>=14;){const N=x>>I-14&16383,C=l[N];if(C.len)I-=C.len,Et(C.lit,R,x,I,f,g,b,A,M),x=Le.c,I=Le.lc;else{if(!C.p)throw new Error("hufDecode issues");let P;for(P=0;P<C.lit;P++){const B=jt(o[C.p[P]]);for(;I<B&&g.value<_;)wt(x,I,f,g),x=_e.c,I=_e.lc;if(I>=B&&Vt(o[C.p[P]])==(x>>I-B&(1<<B)-1)){I-=B,Et(C.p[P],R,x,I,f,g,b,A,M),x=Le.c,I=Le.lc;break}}if(P==C.lit)throw new Error("hufDecode issues")}}const O=8-w&7;for(x>>=O,I-=O;I>0;){const N=l[x<<14-I&16383];if(N.len)I-=N.len,Et(N.lit,R,x,I,f,g,b,A,M),x=Le.c,I=Le.lc;else throw new Error("hufDecode issues")}return!0}function Xt(o,l,f,g,w,R){const m={value:0},b=f.value,A=ye(l,f),x=ye(l,f);f.value+=4;const I=ye(l,f);if(f.value+=4,A<0||A>=65537||x<0||x>=65537)throw new Error("Something wrong with HUF_ENCSIZE");const M=new Array(65537),_=new Array(16384);ce(_);const O=g-(f.value-b);if(Pn(o,f,O,A,x,M),I>8*(g-(f.value-b)))throw new Error("Something wrong with hufUncompress");kn(M,A,x,_),Un(M,_,o,f,I,x,R,w,m)}function Bn(o,l,f){for(let g=0;g<f;++g)l[g]=o[l[g]]}function Kt(o){for(let l=1;l<o.length;l++){const f=o[l-1]+o[l]-128;o[l]=f}}function Zt(o,l){let f=0,g=Math.floor((o.length+1)/2),w=0;const R=o.length-1;for(;!(w>R||(l[w++]=o[f++],w>R));)l[w++]=o[g++]}function Wt(o){let l=o.byteLength;const f=new Array;let g=0;const w=new DataView(o);for(;l>0;){const R=w.getInt8(g++);if(R<0){const m=-R;l-=m+1;for(let b=0;b<m;b++)f.push(w.getUint8(g++))}else{const m=R;l-=2;const b=w.getUint8(g++);for(let A=0;A<m+1;A++)f.push(b)}}return f}function Hn(o,l,f,g,w,R){let m=new DataView(R.buffer);const b=f[o.idx[0]].width,A=f[o.idx[0]].height,x=3,I=Math.floor(b/8),M=Math.ceil(b/8),_=Math.ceil(A/8),O=b-(M-1)*8,N=A-(_-1)*8,C={value:0},P=new Array(x),B=new Array(x),X=new Array(x),Y=new Array(x),ie=new Array(x);for(let H=0;H<x;++H)ie[H]=l[o.idx[H]],P[H]=H<1?0:P[H-1]+M*_,B[H]=new Float32Array(64),X[H]=new Uint16Array(64),Y[H]=new Uint16Array(M*64);for(let H=0;H<_;++H){let ee=8;H==_-1&&(ee=N);let oe=8;for(let z=0;z<M;++z){z==M-1&&(oe=O);for(let q=0;q<x;++q)X[q].fill(0),X[q][0]=w[P[q]++],Yt(C,g,X[q]),qt(X[q],B[q]),$t(B[q]);jn(B);for(let q=0;q<x;++q)Qt(B[q],Y[q],z*64)}let $=0;for(let z=0;z<x;++z){const q=f[o.idx[z]].type;for(let ve=8*H;ve<8*H+ee;++ve){$=ie[z][ve];for(let Ye=0;Ye<I;++Ye){const Se=Ye*64+(ve&7)*8;m.setUint16($+0*q,Y[z][Se+0],!0),m.setUint16($+2*q,Y[z][Se+1],!0),m.setUint16($+4*q,Y[z][Se+2],!0),m.setUint16($+6*q,Y[z][Se+3],!0),m.setUint16($+8*q,Y[z][Se+4],!0),m.setUint16($+10*q,Y[z][Se+5],!0),m.setUint16($+12*q,Y[z][Se+6],!0),m.setUint16($+14*q,Y[z][Se+7],!0),$+=16*q}}if(I!=M)for(let ve=8*H;ve<8*H+ee;++ve){const Ye=ie[z][ve]+8*I*2*q,Se=I*64+(ve&7)*8;for(let ht=0;ht<oe;++ht)m.setUint16(Ye+ht*2*q,Y[z][Se+ht],!0)}}}const W=new Uint16Array(b);m=new DataView(R.buffer);for(let H=0;H<x;++H){f[o.idx[H]].decoded=!0;const ee=f[o.idx[H]].type;if(f[H].type==2)for(let oe=0;oe<A;++oe){const $=ie[H][oe];for(let z=0;z<b;++z)W[z]=m.getUint16($+z*2*ee,!0);for(let z=0;z<b;++z)m.setFloat32($+z*2*ee,D(W[z]),!0)}}}function Gn(o,l,f,g,w,R){const m=new DataView(R.buffer),b=f[o],A=b.width,x=b.height,I=Math.ceil(A/8),M=Math.ceil(x/8),_=Math.floor(A/8),O=A-(I-1)*8,N=x-(M-1)*8,C={value:0};let P=0;const B=new Float32Array(64),X=new Uint16Array(64),Y=new Uint16Array(I*64);for(let ie=0;ie<M;++ie){let W=8;ie==M-1&&(W=N);for(let H=0;H<I;++H)X.fill(0),X[0]=w[P++],Yt(C,g,X),qt(X,B),$t(B),Qt(B,Y,H*64);for(let H=8*ie;H<8*ie+W;++H){let ee=l[o][H];for(let oe=0;oe<_;++oe){const $=oe*64+(H&7)*8;for(let z=0;z<8;++z)m.setUint16(ee+z*2*b.type,Y[$+z],!0);ee+=16*b.type}if(I!=_){const oe=_*64+(H&7)*8;for(let $=0;$<O;++$)m.setUint16(ee+$*2*b.type,Y[oe+$],!0)}}}b.decoded=!0}function Yt(o,l,f){let g,w=1;for(;w<64;)g=l[o.value],g==65280?w=64:g>>8==255?w+=g&255:(f[w]=g,w++),o.value++}function qt(o,l){l[0]=D(o[0]),l[1]=D(o[1]),l[2]=D(o[5]),l[3]=D(o[6]),l[4]=D(o[14]),l[5]=D(o[15]),l[6]=D(o[27]),l[7]=D(o[28]),l[8]=D(o[2]),l[9]=D(o[4]),l[10]=D(o[7]),l[11]=D(o[13]),l[12]=D(o[16]),l[13]=D(o[26]),l[14]=D(o[29]),l[15]=D(o[42]),l[16]=D(o[3]),l[17]=D(o[8]),l[18]=D(o[12]),l[19]=D(o[17]),l[20]=D(o[25]),l[21]=D(o[30]),l[22]=D(o[41]),l[23]=D(o[43]),l[24]=D(o[9]),l[25]=D(o[11]),l[26]=D(o[18]),l[27]=D(o[24]),l[28]=D(o[31]),l[29]=D(o[40]),l[30]=D(o[44]),l[31]=D(o[53]),l[32]=D(o[10]),l[33]=D(o[19]),l[34]=D(o[23]),l[35]=D(o[32]),l[36]=D(o[39]),l[37]=D(o[45]),l[38]=D(o[52]),l[39]=D(o[54]),l[40]=D(o[20]),l[41]=D(o[22]),l[42]=D(o[33]),l[43]=D(o[38]),l[44]=D(o[46]),l[45]=D(o[51]),l[46]=D(o[55]),l[47]=D(o[60]),l[48]=D(o[21]),l[49]=D(o[34]),l[50]=D(o[37]),l[51]=D(o[47]),l[52]=D(o[50]),l[53]=D(o[56]),l[54]=D(o[59]),l[55]=D(o[61]),l[56]=D(o[35]),l[57]=D(o[36]),l[58]=D(o[48]),l[59]=D(o[49]),l[60]=D(o[57]),l[61]=D(o[58]),l[62]=D(o[62]),l[63]=D(o[63])}function $t(o){const l=.5*Math.cos(.7853975),f=.5*Math.cos(3.14159/16),g=.5*Math.cos(3.14159/8),w=.5*Math.cos(3*3.14159/16),R=.5*Math.cos(5*3.14159/16),m=.5*Math.cos(3*3.14159/8),b=.5*Math.cos(7*3.14159/16),A=new Array(4),x=new Array(4),I=new Array(4),M=new Array(4);for(let _=0;_<8;++_){const O=_*8;A[0]=g*o[O+2],A[1]=m*o[O+2],A[2]=g*o[O+6],A[3]=m*o[O+6],x[0]=f*o[O+1]+w*o[O+3]+R*o[O+5]+b*o[O+7],x[1]=w*o[O+1]-b*o[O+3]-f*o[O+5]-R*o[O+7],x[2]=R*o[O+1]-f*o[O+3]+b*o[O+5]+w*o[O+7],x[3]=b*o[O+1]-R*o[O+3]+w*o[O+5]-f*o[O+7],I[0]=l*(o[O+0]+o[O+4]),I[3]=l*(o[O+0]-o[O+4]),I[1]=A[0]+A[3],I[2]=A[1]-A[2],M[0]=I[0]+I[1],M[1]=I[3]+I[2],M[2]=I[3]-I[2],M[3]=I[0]-I[1],o[O+0]=M[0]+x[0],o[O+1]=M[1]+x[1],o[O+2]=M[2]+x[2],o[O+3]=M[3]+x[3],o[O+4]=M[3]-x[3],o[O+5]=M[2]-x[2],o[O+6]=M[1]-x[1],o[O+7]=M[0]-x[0]}for(let _=0;_<8;++_)A[0]=g*o[16+_],A[1]=m*o[16+_],A[2]=g*o[48+_],A[3]=m*o[48+_],x[0]=f*o[8+_]+w*o[24+_]+R*o[40+_]+b*o[56+_],x[1]=w*o[8+_]-b*o[24+_]-f*o[40+_]-R*o[56+_],x[2]=R*o[8+_]-f*o[24+_]+b*o[40+_]+w*o[56+_],x[3]=b*o[8+_]-R*o[24+_]+w*o[40+_]-f*o[56+_],I[0]=l*(o[_]+o[32+_]),I[3]=l*(o[_]-o[32+_]),I[1]=A[0]+A[3],I[2]=A[1]-A[2],M[0]=I[0]+I[1],M[1]=I[3]+I[2],M[2]=I[3]-I[2],M[3]=I[0]-I[1],o[0+_]=M[0]+x[0],o[8+_]=M[1]+x[1],o[16+_]=M[2]+x[2],o[24+_]=M[3]+x[3],o[32+_]=M[3]-x[3],o[40+_]=M[2]-x[2],o[48+_]=M[1]-x[1],o[56+_]=M[0]-x[0]}function jn(o){for(let l=0;l<64;++l){const f=o[0][l],g=o[1][l],w=o[2][l];o[0][l]=f+1.5747*w,o[1][l]=f-.1873*g-.4682*w,o[2][l]=f+1.8556*g}}function Qt(o,l,f){for(let g=0;g<64;++g)l[f+g]=rn.toHalfFloat(Vn(o[g]))}function Vn(o){return o<=1?Math.sign(o)*Math.pow(Math.abs(o),2.2):Math.sign(o)*Math.pow(fe,Math.abs(o)-1)}function At(o){return new DataView(o.array.buffer,o.offset.value,o.size)}function zn(o){const l=o.viewer.buffer.slice(o.offset.value,o.offset.value+o.size),f=new Uint8Array(Wt(l)),g=new Uint8Array(f.length);return Kt(f),Zt(f,g),new DataView(g.buffer)}function St(o){const l=o.array.slice(o.offset.value,o.offset.value+o.size),f=tt(l),g=new Uint8Array(f.length);return Kt(f),Zt(f,g),new DataView(g.buffer)}function Xn(o){const l=o.viewer,f={value:o.offset.value},g=new Uint16Array(o.columns*o.lines*(o.inputChannels.length*o.type)),w=new Uint8Array(8192);let R=0;const m=new Array(o.inputChannels.length);for(let N=0,C=o.inputChannels.length;N<C;N++)m[N]={},m[N].start=R,m[N].end=m[N].start,m[N].nx=o.columns,m[N].ny=o.lines,m[N].size=o.type,R+=m[N].nx*m[N].ny*m[N].size;const b=We(l,f),A=We(l,f);if(A>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(b<=A)for(let N=0;N<A-b+1;N++)w[N+b]=Me(l,f);const x=new Uint16Array(65536),I=xe(w,x),M=ye(l,f);Xt(o.array,l,f,M,g,R);for(let N=0;N<o.inputChannels.length;++N){const C=m[N];for(let P=0;P<m[N].size;++P)Nn(g,C.start+P,C.nx,C.size,C.ny,C.nx*C.size,I)}Bn(x,g,R);let _=0;const O=new Uint8Array(g.buffer.byteLength);for(let N=0;N<o.lines;N++)for(let C=0;C<o.inputChannels.length;C++){const P=m[C],B=P.nx*P.size,X=new Uint8Array(g.buffer,P.end*2,B*2);O.set(X,_),_+=B*2,P.end+=B}return new DataView(O.buffer)}function Kn(o){const l=o.array.slice(o.offset.value,o.offset.value+o.size),f=tt(l),g=o.inputChannels.length*o.lines*o.columns*o.totalBytes,w=new ArrayBuffer(g),R=new DataView(w);let m=0,b=0;const A=new Array(4);for(let x=0;x<o.lines;x++)for(let I=0;I<o.inputChannels.length;I++){let M=0;switch(o.inputChannels[I].pixelType){case 1:A[0]=m,A[1]=A[0]+o.columns,m=A[1]+o.columns;for(let O=0;O<o.columns;++O){const N=f[A[0]++]<<8|f[A[1]++];M+=N,R.setUint16(b,M,!0),b+=2}break;case 2:A[0]=m,A[1]=A[0]+o.columns,A[2]=A[1]+o.columns,m=A[2]+o.columns;for(let O=0;O<o.columns;++O){const N=f[A[0]++]<<24|f[A[1]++]<<16|f[A[2]++]<<8;M+=N,R.setUint32(b,M,!0),b+=4}break}}return R}function Jt(o){const l=o.viewer,f={value:o.offset.value},g=new Uint8Array(o.columns*o.lines*(o.inputChannels.length*o.type*2)),w={version:me(l,f),unknownUncompressedSize:me(l,f),unknownCompressedSize:me(l,f),acCompressedSize:me(l,f),dcCompressedSize:me(l,f),rleCompressedSize:me(l,f),rleUncompressedSize:me(l,f),rleRawSize:me(l,f),totalAcUncompressedCount:me(l,f),totalDcUncompressedCount:me(l,f),acCompression:me(l,f)};if(w.version<2)throw new Error("EXRLoader.parse: "+Fe.compression+" version "+w.version+" is unsupported");const R=new Array;let m=We(l,f)-2;for(;m>0;){const C=ut(l.buffer,f),P=Me(l,f),B=P>>2&3,X=(P>>4)-1,Y=new Int8Array([X])[0],ie=Me(l,f);R.push({name:C,index:Y,type:ie,compression:B}),m-=C.length+3}const b=Fe.channels,A=new Array(o.inputChannels.length);for(let C=0;C<o.inputChannels.length;++C){const P=A[C]={},B=b[C];P.name=B.name,P.compression=0,P.decoded=!1,P.type=B.pixelType,P.pLinear=B.pLinear,P.width=o.columns,P.height=o.lines}const x={idx:new Array(3)};for(let C=0;C<o.inputChannels.length;++C){const P=A[C];for(let B=0;B<R.length;++B){const X=R[B];P.name==X.name&&(P.compression=X.compression,X.index>=0&&(x.idx[X.index]=C),P.offset=C)}}let I,M,_;if(w.acCompressedSize>0)switch(w.acCompression){case 0:I=new Uint16Array(w.totalAcUncompressedCount),Xt(o.array,l,f,w.acCompressedSize,I,w.totalAcUncompressedCount);break;case 1:const C=o.array.slice(f.value,f.value+w.totalAcUncompressedCount),P=tt(C);I=new Uint16Array(P.buffer),f.value+=w.totalAcUncompressedCount;break}if(w.dcCompressedSize>0){const C={array:o.array,offset:f,size:w.dcCompressedSize};M=new Uint16Array(St(C).buffer),f.value+=w.dcCompressedSize}if(w.rleRawSize>0){const C=o.array.slice(f.value,f.value+w.rleCompressedSize),P=tt(C);_=Wt(P.buffer),f.value+=w.rleCompressedSize}let O=0;const N=new Array(A.length);for(let C=0;C<N.length;++C)N[C]=new Array;for(let C=0;C<o.lines;++C)for(let P=0;P<A.length;++P)N[P].push(O),O+=A[P].width*o.type*2;x.idx[0]!==void 0&&A[x.idx[0]]&&Hn(x,N,A,I,M,g);for(let C=0;C<A.length;++C){const P=A[C];if(!P.decoded)switch(P.compression){case 2:let B=0,X=0;for(let Y=0;Y<o.lines;++Y){let ie=N[C][B];for(let W=0;W<P.width;++W){for(let H=0;H<2*P.type;++H)g[ie++]=_[X+H*P.width*P.height];X++}B++}break;case 1:Gn(C,N,A,I,M,g);break;default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(g.buffer)}function ut(o,l){const f=new Uint8Array(o);let g=0;for(;f[l.value+g]!=0;)g+=1;const w=new TextDecoder().decode(f.slice(l.value,l.value+g));return l.value=l.value+g+1,w}function Zn(o,l,f){const g=new TextDecoder().decode(new Uint8Array(o).slice(l.value,l.value+f));return l.value=l.value+f,g}function Wn(o,l){const f=ge(o,l),g=ye(o,l);return[f,g]}function Yn(o,l){const f=ye(o,l),g=ye(o,l);return[f,g]}function ge(o,l){const f=o.getInt32(l.value,!0);return l.value=l.value+4,f}function ye(o,l){const f=o.getUint32(l.value,!0);return l.value=l.value+4,f}function en(o,l){const f=o[l.value];return l.value=l.value+1,f}function Me(o,l){const f=o.getUint8(l.value);return l.value=l.value+1,f}const me=function(o,l){let f;return"getBigInt64"in DataView.prototype?f=Number(o.getBigInt64(l.value,!0)):f=o.getUint32(l.value+4,!0)+Number(o.getUint32(l.value,!0)<<32),l.value+=8,f};function ue(o,l){const f=o.getFloat32(l.value,!0);return l.value+=4,f}function qn(o,l){return rn.toHalfFloat(ue(o,l))}function D(o){const l=(o&31744)>>10,f=o&1023;return(o>>15?-1:1)*(l?l===31?f?NaN:1/0:Math.pow(2,l-15)*(1+f/1024):6103515625e-14*(f/1024))}function We(o,l){const f=o.getUint16(l.value,!0);return l.value+=2,f}function $n(o,l){return D(We(o,l))}function Qn(o,l,f,g){const w=f.value,R=[];for(;f.value<w+g-1;){const m=ut(l,f),b=ge(o,f),A=Me(o,f);f.value+=3;const x=ge(o,f),I=ge(o,f);R.push({name:m,pixelType:b,pLinear:A,xSampling:x,ySampling:I})}return f.value+=1,R}function Jn(o,l){const f=ue(o,l),g=ue(o,l),w=ue(o,l),R=ue(o,l),m=ue(o,l),b=ue(o,l),A=ue(o,l),x=ue(o,l);return{redX:f,redY:g,greenX:w,greenY:R,blueX:m,blueY:b,whiteX:A,whiteY:x}}function es(o,l){const f=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],g=Me(o,l);return f[g]}function ts(o,l){const f=ge(o,l),g=ge(o,l),w=ge(o,l),R=ge(o,l);return{xMin:f,yMin:g,xMax:w,yMax:R}}function ns(o,l){const f=["INCREASING_Y","DECREASING_Y","RANDOM_Y"],g=Me(o,l);return f[g]}function ss(o,l){const f=["ENVMAP_LATLONG","ENVMAP_CUBE"],g=Me(o,l);return f[g]}function rs(o,l){const f=["ONE_LEVEL","MIPMAP_LEVELS","RIPMAP_LEVELS"],g=["ROUND_DOWN","ROUND_UP"],w=ye(o,l),R=ye(o,l),m=Me(o,l);return{xSize:w,ySize:R,levelMode:f[m&15],roundingMode:g[m>>4]}}function is(o,l){const f=ue(o,l),g=ue(o,l);return[f,g]}function os(o,l){const f=ue(o,l),g=ue(o,l),w=ue(o,l);return[f,g,w]}function as(o,l,f,g,w){if(g==="string"||g==="stringvector"||g==="iccProfile")return Zn(l,f,w);if(g==="chlist")return Qn(o,l,f,w);if(g==="chromaticities")return Jn(o,f);if(g==="compression")return es(o,f);if(g==="box2i")return ts(o,f);if(g==="envmap")return ss(o,f);if(g==="tiledesc")return rs(o,f);if(g==="lineOrder")return ns(o,f);if(g==="float")return ue(o,f);if(g==="v2f")return is(o,f);if(g==="v3f")return os(o,f);if(g==="int")return ge(o,f);if(g==="rational")return Wn(o,f);if(g==="timecode")return Yn(o,f);if(g==="preview")return f.value+=w,"skipped";f.value+=w}function cs(o,l){const f=Math.log2(o);return l=="ROUND_DOWN"?Math.floor(f):Math.ceil(f)}function ls(o,l,f){let g=0;switch(o.levelMode){case"ONE_LEVEL":g=1;break;case"MIPMAP_LEVELS":g=cs(Math.max(l,f),o.roundingMode)+1;break;case"RIPMAP_LEVELS":throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")}return g}function tn(o,l,f,g){const w=new Array(o);for(let R=0;R<o;R++){const m=1<<R;let b=l/m|0;g=="ROUND_UP"&&b*m<l&&(b+=1);const A=Math.max(b,1);w[R]=(A+f-1)/f|0}return w}function us(){const o=this,l=o.offset,f={value:0};for(let g=0;g<o.tileCount;g++){const w=ge(o.viewer,l),R=ge(o.viewer,l);l.value+=8,o.size=ye(o.viewer,l);const m=w*o.blockWidth,b=R*o.blockHeight;o.columns=m+o.blockWidth>o.width?o.width-m:o.blockWidth,o.lines=b+o.blockHeight>o.height?o.height-b:o.blockHeight;const A=o.columns*o.totalBytes,I=o.size<o.lines*A?o.uncompress(o):At(o);l.value+=o.size;for(let M=0;M<o.lines;M++){const _=M*o.columns*o.totalBytes;for(let O=0;O<o.inputChannels.length;O++){const N=Fe.channels[O].name,C=o.channelByteOffsets[N]*o.columns,P=o.decodeChannels[N];if(P===void 0)continue;f.value=_+C;const B=(o.height-(1+b+M))*o.outLineWidth;for(let X=0;X<o.columns;X++){const Y=B+(X+m)*o.outputChannels+P;o.byteArray[Y]=o.getter(I,f)}}}}}function hs(){const o=this,l=o.offset,f={value:0};for(let g=0;g<o.height/o.blockHeight;g++){const w=ge(o.viewer,l)-Fe.dataWindow.yMin;o.size=ye(o.viewer,l),o.lines=w+o.blockHeight>o.height?o.height-w:o.blockHeight;const R=o.columns*o.totalBytes,b=o.size<o.lines*R?o.uncompress(o):At(o);l.value+=o.size;for(let A=0;A<o.blockHeight;A++){const x=g*o.blockHeight,I=A+o.scanOrder(x);if(I>=o.height)continue;const M=A*R,_=(o.height-1-I)*o.outLineWidth;for(let O=0;O<o.inputChannels.length;O++){const N=Fe.channels[O].name,C=o.channelByteOffsets[N]*o.columns,P=o.decodeChannels[N];if(P!==void 0){f.value=M+C;for(let B=0;B<o.columns;B++){const X=_+B*o.outputChannels+P;o.byteArray[X]=o.getter(b,f)}}}}}}function ps(o,l,f){const g={};if(o.getUint32(0,!0)!=20000630)throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");g.version=o.getUint8(4);const w=o.getUint8(5);g.spec={singleTile:!!(w&2),longName:!!(w&4),deepFormat:!!(w&8),multiPart:!!(w&16)},f.value=8;let R=!0;for(;R;){const m=ut(l,f);if(m==="")R=!1;else{const b=ut(l,f),A=ye(o,f),x=as(o,l,f,b,A);x===void 0?console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${b}'.`):g[m]=x}}if((w&-7)!=0)throw console.error("THREE.EXRHeader:",g),new Error("THREE.EXRLoader: Provided file is currently unsupported.");return g}function fs(o,l,f,g,w,R){const m={size:0,viewer:l,array:f,offset:g,width:o.dataWindow.xMax-o.dataWindow.xMin+1,height:o.dataWindow.yMax-o.dataWindow.yMin+1,inputChannels:o.channels,channelByteOffsets:{},shouldExpand:!1,scanOrder:null,totalBytes:null,columns:null,lines:null,type:null,uncompress:null,getter:null,format:null,colorSpace:le};switch(o.compression){case"NO_COMPRESSION":m.blockHeight=1,m.uncompress=At;break;case"RLE_COMPRESSION":m.blockHeight=1,m.uncompress=zn;break;case"ZIPS_COMPRESSION":m.blockHeight=1,m.uncompress=St;break;case"ZIP_COMPRESSION":m.blockHeight=16,m.uncompress=St;break;case"PIZ_COMPRESSION":m.blockHeight=32,m.uncompress=Xn;break;case"PXR24_COMPRESSION":m.blockHeight=16,m.uncompress=Kn;break;case"DWAA_COMPRESSION":m.blockHeight=32,m.uncompress=Jt;break;case"DWAB_COMPRESSION":m.blockHeight=256,m.uncompress=Jt;break;default:throw new Error("EXRLoader.parse: "+o.compression+" is unsupported")}const b={};for(const _ of o.channels)switch(_.name){case"Y":case"R":case"G":case"B":case"A":b[_.name]=!0,m.type=_.pixelType}let A=!1,x=!1;if(b.R&&b.G&&b.B)m.outputChannels=4;else if(b.Y)m.outputChannels=1;else throw new Error("EXRLoader.parse: file contains unsupported data channels.");switch(m.outputChannels){case 4:R==Be?(A=!b.A,m.format=Be,m.colorSpace=le,m.outputChannels=4,m.decodeChannels={R:0,G:1,B:2,A:3}):R==qe?(m.format=qe,m.colorSpace=le,m.outputChannels=2,m.decodeChannels={R:0,G:1}):R==ft?(m.format=ft,m.colorSpace=le,m.outputChannels=1,m.decodeChannels={R:0}):x=!0;break;case 1:R==Be?(A=!0,m.format=Be,m.colorSpace=le,m.outputChannels=4,m.shouldExpand=!0,m.decodeChannels={Y:0}):R==qe?(m.format=qe,m.colorSpace=le,m.outputChannels=2,m.shouldExpand=!0,m.decodeChannels={Y:0}):R==ft?(m.format=ft,m.colorSpace=le,m.outputChannels=1,m.decodeChannels={Y:0}):x=!0;break;default:x=!0}if(x)throw new Error("EXRLoader.parse: invalid output format for specified file.");if(m.type==1)switch(w){case It:m.getter=$n;break;case pt:m.getter=We;break}else if(m.type==2)switch(w){case It:m.getter=ue;break;case pt:m.getter=qn}else throw new Error("EXRLoader.parse: unsupported pixelType "+m.type+" for "+o.compression+".");m.columns=m.width;const I=m.width*m.height*m.outputChannels;switch(w){case It:m.byteArray=new Float32Array(I),A&&m.byteArray.fill(1,0,I);break;case pt:m.byteArray=new Uint16Array(I),A&&m.byteArray.fill(15360,0,I);break;default:console.error("THREE.EXRLoader: unsupported type: ",w);break}let M=0;for(const _ of o.channels)m.decodeChannels[_.name]!==void 0&&(m.channelByteOffsets[_.name]=M),M+=_.pixelType*2;if(m.totalBytes=M,m.outLineWidth=m.width*m.outputChannels,o.lineOrder==="INCREASING_Y"?m.scanOrder=_=>_:m.scanOrder=_=>m.height-1-_,o.spec.singleTile){m.blockHeight=o.tiles.ySize,m.blockWidth=o.tiles.xSize;const _=ls(o.tiles,m.width,m.height),O=tn(_,m.width,o.tiles.xSize,o.tiles.roundingMode),N=tn(_,m.height,o.tiles.ySize,o.tiles.roundingMode);m.tileCount=O[0]*N[0];for(let C=0;C<_;C++)for(let P=0;P<N[C];P++)for(let B=0;B<O[C];B++)me(l,g);m.decode=us.bind(m)}else{m.blockWidth=m.width;const _=Math.ceil(m.height/m.blockHeight);for(let O=0;O<_;O++)me(l,g);m.decode=hs.bind(m)}return m}const nn={value:0},sn=new DataView(e),ds=new Uint8Array(e),Fe=ps(sn,e,nn),Ce=fs(Fe,sn,ds,nn,this.type,this.outputFormat);if(Ce.decode(),Ce.shouldExpand){const o=Ce.byteArray;if(this.outputFormat==Be)for(let l=0;l<o.length;l+=4)o[l+2]=o[l+1]=o[l];else if(this.outputFormat==qe)for(let l=0;l<o.length;l+=2)o[l+1]=o[l]}return{header:Fe,width:Ce.width,height:Ce.height,data:Ce.byteArray,format:Ce.format,colorSpace:Ce.colorSpace,type:this.type}}setDataType(e){return this.type=e,this}setOutputFormat(e){return this.outputFormat=e,this}load(e,t,s,n){function r(i,a){i.colorSpace=a.colorSpace,i.minFilter=it,i.magFilter=it,i.generateMipmaps=!1,i.flipY=!1,t&&t(i,a)}return super.load(e,r,s,n)}}const Rt=new WeakMap;class Vs extends Xe{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,s,n){const r=new Ke(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,i=>{this.parse(i,t,n)},s,n)}parse(e,t,s=()=>{}){this.decodeDracoFile(e,t,null,null,te,s).catch(s)}decodeDracoFile(e,t,s,n,r=le,i=()=>{}){const a={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!s,vertexColorSpace:r};return this.decodeGeometry(e,a).then(t).catch(i)}decodeGeometry(e,t){const s=JSON.stringify(t);if(Rt.has(e)){const c=Rt.get(e);if(c.key===s)return c.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const r=this.workerNextTaskID++,i=e.byteLength,a=this._getWorker(r,i).then(c=>(n=c,new Promise((u,h)=>{n._callbacks[r]={resolve:u,reject:h},n.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))).then(c=>this._createGeometry(c.geometry));return a.catch(()=>!0).then(()=>{n&&r&&this._releaseTask(n,r)}),Rt.set(e,{key:s,promise:a}),a}_createGeometry(e){const t=new ke;e.index&&t.setIndex(new nt(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const n=e.attributes[s],r=n.name,i=n.array,a=n.itemSize,c=new nt(i,a);r==="color"&&(this._assignVertexColorSpace(c,n.vertexColorSpace),c.normalized=!(i instanceof Float32Array)),t.setAttribute(r,c)}return t}_assignVertexColorSpace(e,t){if(t!==te)return;const s=new ae;for(let n=0,r=e.count;n<r;n++)s.fromBufferAttribute(e,n),Ae.colorSpaceToWorking(s,te),e.setXYZ(n,s.r,s.g,s.b)}_loadLibrary(e,t){const s=new Ke(this.manager);return s.setPath(this.decoderPath),s.setResponseType(t),s.setWithCredentials(this.withCredentials),new Promise((n,r)=>{s.load(e,n,void 0,r)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(s=>{const n=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const r=zs.toString(),i=["/* draco decoder */",n,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([i]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const n=new Worker(this.workerSourceURL);n._callbacks={},n._taskCosts={},n._taskLoad=0,n.postMessage({type:"init",decoderConfig:this.decoderConfig}),n.onmessage=function(r){const i=r.data;switch(i.type){case"decode":n._callbacks[i.id].resolve(i);break;case"error":n._callbacks[i.id].reject(i);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+i.type+'"')}},this.workerPool.push(n)}else this.workerPool.sort(function(n,r){return n._taskLoad>r._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=t,s._taskLoad+=t,s})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function zs(){let T,e;onmessage=function(i){const a=i.data;switch(a.type){case"init":T=a.decoderConfig,e=new Promise(function(h){T.onModuleLoaded=function(p){h({draco:p})},DracoDecoderModule(T)});break;case"decode":const c=a.buffer,u=a.taskConfig;e.then(h=>{const p=h.draco,d=new p.Decoder;try{const y=t(p,d,new Int8Array(c),u),E=y.attributes.map(v=>v.array.buffer);y.index&&E.push(y.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:y},E)}catch(y){console.error(y),self.postMessage({type:"error",id:a.id,error:y.message})}finally{p.destroy(d)}});break}};function t(i,a,c,u){const h=u.attributeIDs,p=u.attributeTypes;let d,y;const E=a.GetEncodedGeometryType(c);if(E===i.TRIANGULAR_MESH)d=new i.Mesh,y=a.DecodeArrayToMesh(c,c.byteLength,d);else if(E===i.POINT_CLOUD)d=new i.PointCloud,y=a.DecodeArrayToPointCloud(c,c.byteLength,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!y.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+y.error_msg());const v={index:null,attributes:[]};for(const S in h){const L=self[p[S]];let k,F;if(u.useUniqueIDs)F=h[S],k=a.GetAttributeByUniqueId(d,F);else{if(F=a.GetAttributeId(d,i[h[S]]),F===-1)continue;k=a.GetAttribute(d,F)}const U=n(i,a,d,S,L,k);S==="color"&&(U.vertexColorSpace=u.vertexColorSpace),v.attributes.push(U)}return E===i.TRIANGULAR_MESH&&(v.index=s(i,a,d)),i.destroy(d),v}function s(i,a,c){const h=c.num_faces()*3,p=h*4,d=i._malloc(p);a.GetTrianglesUInt32Array(c,p,d);const y=new Uint32Array(i.HEAPF32.buffer,d,h).slice();return i._free(d),{array:y,itemSize:1}}function n(i,a,c,u,h,p){const d=p.num_components(),E=c.num_points()*d,v=E*h.BYTES_PER_ELEMENT,S=r(i,h),L=i._malloc(v);a.GetAttributeDataArrayForAllPoints(c,p,S,v,L);const k=new h(i.HEAPF32.buffer,L,E).slice();return i._free(L),{name:u,array:k,itemSize:d}}function r(i,a){switch(a){case Float32Array:return i.DT_FLOAT32;case Int8Array:return i.DT_INT8;case Int16Array:return i.DT_INT16;case Int32Array:return i.DT_INT32;case Uint8Array:return i.DT_UINT8;case Uint16Array:return i.DT_UINT16;case Uint32Array:return i.DT_UINT32}}}const Zr=Object.freeze(Object.defineProperty({__proto__:null,DRACOLoader:Vs},Symbol.toStringTag,{value:"Module"}));let G,ne,pe;class Xs extends Xe{constructor(e){super(e)}load(e,t,s,n){const r=this,i=r.path===""?je.extractUrlBase(e):r.path,a=new Ke(this.manager);a.setPath(r.path),a.setResponseType("arraybuffer"),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(c){try{t(r.parse(c,i))}catch(u){n?n(u):console.error(u),r.manager.itemError(e)}},s,n)}parse(e,t){if($s(e))G=new qs().parse(e);else{const n=Cn(e);if(!Qs(n))throw new Error("THREE.FBXLoader: Unknown format.");if(cn(n)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+cn(n));G=new Ys().parse(n)}const s=new yn(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Ks(s,this.manager).parse(G)}}class Ks{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){ne=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),s=this.parseMaterials(t),n=this.parseDeformers(),r=new Zs().parse(n);return this.parseScene(n,r,s),pe}parseConnections(){const e=new Map;return"Connections"in G&&G.Connections.connections.forEach(function(s){const n=s[0],r=s[1],i=s[2];e.has(n)||e.set(n,{parents:[],children:[]});const a={ID:r,relationship:i};e.get(n).parents.push(a),e.has(r)||e.set(r,{parents:[],children:[]});const c={ID:n,relationship:i};e.get(r).children.push(c)}),e}parseImages(){const e={},t={};if("Video"in G.Objects){const s=G.Objects.Video;for(const n in s){const r=s[n],i=parseInt(n);if(e[i]=r.RelativeFilename||r.Filename,"Content"in r){const a=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,c=typeof r.Content=="string"&&r.Content!=="";if(a||c){const u=this.parseImage(s[n]);t[r.RelativeFilename||r.Filename]=u}}}}for(const s in e){const n=e[s];t[n]!==void 0?e[s]=t[n]:e[s]=e[s].split("\\").pop()}return e}parseImage(e){const t=e.Content,s=e.RelativeFilename||e.Filename,n=s.slice(s.lastIndexOf(".")+1).toLowerCase();let r;switch(n){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",s),r="image/tga";break;case"webp":r="image/webp";break;default:console.warn('FBXLoader: Image type "'+n+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const i=new Uint8Array(t);return window.URL.createObjectURL(new Blob([i],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in G.Objects){const s=G.Objects.Texture;for(const n in s){const r=this.parseTexture(s[n],e);t.set(parseInt(n),r)}}return t}parseTexture(e,t){const s=this.loadTexture(e,t);s.ID=e.id,s.name=e.attrName;const n=e.WrapModeU,r=e.WrapModeV,i=n!==void 0?n.value:0,a=r!==void 0?r.value:0;if(s.wrapS=i===0?ot:Ot,s.wrapT=a===0?ot:Ot,"Scaling"in e){const c=e.Scaling.value;s.repeat.x=c[0],s.repeat.y=c[1]}if("Translation"in e){const c=e.Translation.value;s.offset.x=c[0],s.offset.y=c[1]}return s}loadTexture(e,t){const s=e.FileName.split(".").pop().toLowerCase();let n=this.manager.getHandler(`.${s}`);n===null&&(n=this.textureLoader);const r=n.path;r||n.setPath(this.textureLoader.path);const i=ne.get(e.id).children;let a;if(i!==void 0&&i.length>0&&t[i[0].ID]!==void 0&&(a=t[i[0].ID],(a.indexOf("blob:")===0||a.indexOf("data:")===0)&&n.setPath(void 0)),a===void 0)return console.warn("FBXLoader: Undefined filename, creating placeholder texture."),new Ft;const c=n.load(a);return n.setPath(r),c}parseMaterials(e){const t=new Map;if("Material"in G.Objects){const s=G.Objects.Material;for(const n in s){const r=this.parseMaterial(s[n],e);r!==null&&t.set(parseInt(n),r)}}return t}parseMaterial(e,t){const s=e.id,n=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!ne.has(s))return null;const i=this.parseParameters(e,t,s);let a;switch(r.toLowerCase()){case"phong":a=new Qe;break;case"lambert":a=new gs;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),a=new Qe;break}return a.setValues(i),a.name=n,a}parseParameters(e,t,s){const n={};e.BumpFactor&&(n.bumpScale=e.BumpFactor.value),e.Diffuse?n.color=Ae.colorSpaceToWorking(new ae().fromArray(e.Diffuse.value),te):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(n.color=Ae.colorSpaceToWorking(new ae().fromArray(e.DiffuseColor.value),te)),e.DisplacementFactor&&(n.displacementScale=e.DisplacementFactor.value),e.Emissive?n.emissive=Ae.colorSpaceToWorking(new ae().fromArray(e.Emissive.value),te):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(n.emissive=Ae.colorSpaceToWorking(new ae().fromArray(e.EmissiveColor.value),te)),e.EmissiveFactor&&(n.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),n.opacity=1-(e.TransparencyFactor?parseFloat(e.TransparencyFactor.value):0),(n.opacity===1||n.opacity===0)&&(n.opacity=e.Opacity?parseFloat(e.Opacity.value):null,n.opacity===null&&(n.opacity=1-(e.TransparentColor?parseFloat(e.TransparentColor.value[0]):0))),n.opacity<1&&(n.transparent=!0),e.ReflectionFactor&&(n.reflectivity=e.ReflectionFactor.value),e.Shininess&&(n.shininess=e.Shininess.value),e.Specular?n.specular=Ae.colorSpaceToWorking(new ae().fromArray(e.Specular.value),te):e.SpecularColor&&e.SpecularColor.type==="Color"&&(n.specular=Ae.colorSpaceToWorking(new ae().fromArray(e.SpecularColor.value),te));const r=this;return ne.get(s).children.forEach(function(i){const a=i.relationship;switch(a){case"Bump":n.bumpMap=r.getTexture(t,i.ID);break;case"Maya|TEX_ao_map":n.aoMap=r.getTexture(t,i.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":n.map=r.getTexture(t,i.ID),n.map!==void 0&&(n.map.colorSpace=te);break;case"DisplacementColor":n.displacementMap=r.getTexture(t,i.ID);break;case"EmissiveColor":n.emissiveMap=r.getTexture(t,i.ID),n.emissiveMap!==void 0&&(n.emissiveMap.colorSpace=te);break;case"NormalMap":case"Maya|TEX_normal_map":n.normalMap=r.getTexture(t,i.ID);break;case"ReflectionColor":n.envMap=r.getTexture(t,i.ID),n.envMap!==void 0&&(n.envMap.mapping=ys,n.envMap.colorSpace=te);break;case"SpecularColor":n.specularMap=r.getTexture(t,i.ID),n.specularMap!==void 0&&(n.specularMap.colorSpace=te);break;case"TransparentColor":case"TransparencyFactor":n.alphaMap=r.getTexture(t,i.ID),n.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),n}getTexture(e,t){return"LayeredTexture"in G.Objects&&t in G.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=ne.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in G.Objects){const s=G.Objects.Deformer;for(const n in s){const r=s[n],i=ne.get(parseInt(n));if(r.attrType==="Skin"){const a=this.parseSkeleton(i,s);a.ID=n,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=i.parents[0].ID,e[n]=a}else if(r.attrType==="BlendShape"){const a={id:n};a.rawTargets=this.parseMorphTargets(i,s),a.id=n,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const s=[];return e.children.forEach(function(n){const r=t[n.ID];if(r.attrType!=="Cluster")return;const i={ID:n.ID,indices:[],weights:[],transformLink:new Q().fromArray(r.TransformLink.a)};"Indexes"in r&&(i.indices=r.Indexes.a,i.weights=r.Weights.a),s.push(i)}),{rawBones:s,bones:[]}}parseMorphTargets(e,t){const s=[];for(let n=0;n<e.children.length;n++){const r=e.children[n],i=t[r.ID],a={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if(i.attrType!=="BlendShapeChannel")return;a.geoID=ne.get(parseInt(r.ID)).children.filter(function(c){return c.relationship===void 0})[0].ID,s.push(a)}return s}parseScene(e,t,s){pe=new Ve;const n=this.parseModels(e.skeletons,t,s),r=G.Objects.Model,i=this;n.forEach(function(c){const u=r[c.ID];i.setLookAtProperties(c,u),ne.get(c.ID).parents.forEach(function(p){const d=n.get(p.ID);d!==void 0&&d.add(c)}),c.parent===null&&pe.add(c)}),this.bindSkeleton(e.skeletons,t,n),this.addGlobalSceneSettings(),pe.traverse(function(c){if(c.userData.transformData){c.parent&&(c.userData.transformData.parentMatrix=c.parent.matrix,c.userData.transformData.parentMatrixWorld=c.parent.matrixWorld);const u=Mn(c.userData.transformData);c.applyMatrix4(u),c.updateWorldMatrix()}});const a=new Ws().parse();pe.children.length===1&&pe.children[0].isGroup&&(pe.children[0].animations=a,pe=pe.children[0]),pe.animations=a}parseModels(e,t,s){const n=new Map,r=G.Objects.Model;for(const i in r){const a=parseInt(i),c=r[i],u=ne.get(a);let h=this.buildSkeleton(u,e,a,c.attrName);if(!h){switch(c.attrType){case"Camera":h=this.createCamera(u);break;case"Light":h=this.createLight(u);break;case"Mesh":h=this.createMesh(u,t,s);break;case"NurbsCurve":h=this.createCurve(u,t);break;case"LimbNode":case"Root":h=new Dt;break;case"Null":default:h=new Ve;break}h.name=c.attrName?at.sanitizeNodeName(c.attrName):"",h.userData.originalName=c.attrName,h.ID=a}this.getTransformData(h,c),n.set(a,h)}return n}buildSkeleton(e,t,s,n){let r=null;return e.parents.forEach(function(i){for(const a in t){const c=t[a];c.rawBones.forEach(function(u,h){if(u.ID===i.ID){const p=r;r=new Dt,r.matrixWorld.copy(u.transformLink),r.name=n?at.sanitizeNodeName(n):"",r.userData.originalName=n,r.ID=s,c.bones[h]=r,p!==null&&r.add(p)}})}}),r}createCamera(e){let t,s;if(e.children.forEach(function(n){const r=G.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new Ge;else{let n=0;s.CameraProjectionType!==void 0&&s.CameraProjectionType.value===1&&(n=1);let r=1;s.NearPlane!==void 0&&(r=s.NearPlane.value/1e3);let i=1e3;s.FarPlane!==void 0&&(i=s.FarPlane.value/1e3);let a=window.innerWidth,c=window.innerHeight;s.AspectWidth!==void 0&&s.AspectHeight!==void 0&&(a=s.AspectWidth.value,c=s.AspectHeight.value);const u=a/c;let h=45;s.FieldOfView!==void 0&&(h=s.FieldOfView.value);const p=s.FocalLength?s.FocalLength.value:null;switch(n){case 0:t=new Tn(h,u,r,i),p!==null&&t.setFocalLength(p);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),t=new Ge;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+n+"."),t=new Ge;break}}return t}createLight(e){let t,s;if(e.children.forEach(function(n){const r=G.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new Ge;else{let n;s.LightType===void 0?n=0:n=s.LightType.value;let r=16777215;s.Color!==void 0&&(r=Ae.colorSpaceToWorking(new ae().fromArray(s.Color.value),te));let i=s.Intensity===void 0?1:s.Intensity.value/100;s.CastLightOnObject!==void 0&&s.CastLightOnObject.value===0&&(i=0);let a=0;s.FarAttenuationEnd!==void 0&&(s.EnableFarAttenuation!==void 0&&s.EnableFarAttenuation.value===0?a=0:a=s.FarAttenuationEnd.value);const c=1;switch(n){case 0:t=new Pt(r,i,a,c);break;case 1:t=new En(r,i);break;case 2:let u=Math.PI/3;s.InnerAngle!==void 0&&(u=he.degToRad(s.InnerAngle.value));let h=0;s.OuterAngle!==void 0&&(h=he.degToRad(s.OuterAngle.value),h=Math.max(h,1)),t=new wn(r,i,a,u,h,c);break;default:console.warn("THREE.FBXLoader: Unknown light type "+s.LightType.value+", defaulting to a PointLight."),t=new Pt(r,i);break}s.CastShadows!==void 0&&s.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,s){let n,r=null,i=null;const a=[];if(e.children.forEach(function(c){t.has(c.ID)&&(r=t.get(c.ID)),s.has(c.ID)&&a.push(s.get(c.ID))}),a.length>1?i=a:a.length>0?i=a[0]:(i=new Qe({name:Xe.DEFAULT_MATERIAL_NAME,color:13421772}),a.push(i)),"color"in r.attributes&&a.forEach(function(c){c.vertexColors=!0}),r.groups.length>0){let c=!1;for(let u=0,h=r.groups.length;u<h;u++){const p=r.groups[u];(p.materialIndex<0||p.materialIndex>=a.length)&&(p.materialIndex=a.length,c=!0)}if(c){const u=new Qe;a.push(u)}}return r.FBX_Deformer?(n=new xn(r,i),n.normalizeSkinWeights()):n=new yt(r,i),n}createCurve(e,t){const s=e.children.reduce(function(r,i){return t.has(i.ID)&&(r=t.get(i.ID)),r},null),n=new st({name:Xe.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new An(s,n)}getTransformData(e,t){const s={};"InheritType"in t&&(s.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?s.eulerOrder=ct(t.RotationOrder.value):s.eulerOrder=ct(0),"Lcl_Translation"in t&&(s.translation=t.Lcl_Translation.value),"PreRotation"in t&&(s.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(s.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(s.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(s.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(s.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(s.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(s.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(s.rotationPivot=t.RotationPivot.value),e.userData.transformData=s}setLookAtProperties(e,t){"LookAtProperty"in t&&ne.get(e.ID).children.forEach(function(n){if(n.relationship==="LookAtProperty"){const r=G.Objects.Model[n.ID];if("Lcl_Translation"in r){const i=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(i),pe.add(e.target)):e.lookAt(new se().fromArray(i))}}})}bindSkeleton(e,t,s){const n=this.parsePoseNodes();for(const r in e){const i=e[r];ne.get(parseInt(i.ID)).parents.forEach(function(c){if(t.has(c.ID)){const u=c.ID;ne.get(u).parents.forEach(function(p){s.has(p.ID)&&s.get(p.ID).bind(new Sn(i.bones),n[p.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in G.Objects){const t=G.Objects.Pose;for(const s in t)if(t[s].attrType==="BindPose"&&t[s].NbPoseNodes>0){const n=t[s].PoseNode;Array.isArray(n)?n.forEach(function(r){e[r.Node]=new Q().fromArray(r.Matrix.a)}):e[n.Node]=new Q().fromArray(n.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in G){if("AmbientColor"in G.GlobalSettings){const e=G.GlobalSettings.AmbientColor.value,t=e[0],s=e[1],n=e[2];if(t!==0||s!==0||n!==0){const r=new ae().setRGB(t,s,n,te);pe.add(new Ts(r,1))}}"UnitScaleFactor"in G.GlobalSettings&&(pe.userData.unitScaleFactor=G.GlobalSettings.UnitScaleFactor.value)}}}class Zs{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in G.Objects){const s=G.Objects.Geometry;for(const n in s){const r=ne.get(parseInt(n)),i=this.parseGeometry(r,s[n],e);t.set(parseInt(n),i)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,s){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,s);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,s){const n=s.skeletons,r=[],i=e.parents.map(function(p){return G.Objects.Model[p.ID]});if(i.length===0)return;const a=e.children.reduce(function(p,d){return n[d.ID]!==void 0&&(p=n[d.ID]),p},null);e.children.forEach(function(p){s.morphTargets[p.ID]!==void 0&&r.push(s.morphTargets[p.ID])});const c=i[0],u={};"RotationOrder"in c&&(u.eulerOrder=ct(c.RotationOrder.value)),"InheritType"in c&&(u.inheritType=parseInt(c.InheritType.value)),"GeometricTranslation"in c&&(u.translation=c.GeometricTranslation.value),"GeometricRotation"in c&&(u.rotation=c.GeometricRotation.value),"GeometricScaling"in c&&(u.scale=c.GeometricScaling.value);const h=Mn(u);return this.genGeometry(t,a,r,h)}genGeometry(e,t,s,n){const r=new ke;e.attrName&&(r.name=e.attrName);const i=this.parseGeoNode(e,t),a=this.genBuffers(i),c=new Ee(a.vertex,3);if(c.applyMatrix4(n),r.setAttribute("position",c),a.colors.length>0&&r.setAttribute("color",new Ee(a.colors,3)),t&&(r.setAttribute("skinIndex",new ws(a.weightsIndices,4)),r.setAttribute("skinWeight",new Ee(a.vertexWeights,4)),r.FBX_Deformer=t),a.normal.length>0){const u=new Es().getNormalMatrix(n),h=new Ee(a.normal,3);h.applyNormalMatrix(u),r.setAttribute("normal",h)}if(a.uvs.forEach(function(u,h){const p=h===0?"uv":`uv${h}`;r.setAttribute(p,new Ee(a.uvs[h],2))}),i.material&&i.material.mappingType!=="AllSame"){let u=a.materialIndex[0],h=0;if(a.materialIndex.forEach(function(p,d){p!==u&&(r.addGroup(h,d-h,u),u=p,h=d)}),r.groups.length>0){const p=r.groups[r.groups.length-1],d=p.start+p.count;d!==a.materialIndex.length&&r.addGroup(d,a.materialIndex.length-d,u)}r.groups.length===0&&r.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(r,e,s,n),r}parseGeoNode(e,t){const s={};if(s.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],s.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&e.LayerElementColor[0].Colors&&(s.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(s.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(s.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){s.uv=[];let n=0;for(;e.LayerElementUV[n];)e.LayerElementUV[n].UV&&s.uv.push(this.parseUVs(e.LayerElementUV[n])),n++}return s.weightTable={},t!==null&&(s.skeleton=t,t.rawBones.forEach(function(n,r){n.indices.forEach(function(i,a){s.weightTable[i]===void 0&&(s.weightTable[i]=[]),s.weightTable[i].push({id:r,weight:n.weights[a]})})})),s}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let s=0,n=0,r=!1,i=[],a=[],c=[],u=[],h=[],p=[];const d=this;return e.vertexIndices.forEach(function(y,E){let v,S=!1;y<0&&(y=y^-1,S=!0);let L=[],k=[];if(i.push(y*3,y*3+1,y*3+2),e.color){const F=dt(E,s,y,e.color);c.push(F[0],F[1],F[2])}if(e.skeleton){if(e.weightTable[y]!==void 0&&e.weightTable[y].forEach(function(F){k.push(F.weight),L.push(F.id)}),k.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const F=[0,0,0,0],U=[0,0,0,0];k.forEach(function(Z,j){let K=Z,re=L[j];U.forEach(function(fe,xe,ce){if(K>fe){ce[xe]=K,K=fe;const de=F[xe];F[xe]=re,re=de}})}),L=F,k=U}for(;k.length<4;)k.push(0),L.push(0);for(let F=0;F<4;++F)h.push(k[F]),p.push(L[F])}if(e.normal){const F=dt(E,s,y,e.normal);a.push(F[0],F[1],F[2])}e.material&&e.material.mappingType!=="AllSame"&&(v=dt(E,s,y,e.material)[0],v<0&&(d.negativeMaterialIndices=!0,v=0)),e.uv&&e.uv.forEach(function(F,U){const Z=dt(E,s,y,F);u[U]===void 0&&(u[U]=[]),u[U].push(Z[0]),u[U].push(Z[1])}),n++,S&&(d.genFace(t,e,i,v,a,c,u,h,p,n),s++,n=0,i=[],a=[],c=[],u=[],h=[],p=[])}),t}getNormalNewell(e){const t=new se(0,0,0);for(let s=0;s<e.length;s++){const n=e[s],r=e[(s+1)%e.length];t.x+=(n.y-r.y)*(n.z+r.z),t.y+=(n.z-r.z)*(n.x+r.x),t.z+=(n.x-r.x)*(n.y+r.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),n=(Math.abs(t.z)>.5?new se(0,1,0):new se(0,0,1)).cross(t).normalize(),r=t.clone().cross(n).normalize();return{normal:t,tangent:n,bitangent:r}}flattenVertex(e,t,s){return new Gt(e.dot(t),e.dot(s))}genFace(e,t,s,n,r,i,a,c,u,h){let p;if(h>3){const d=[],y=t.baseVertexPositions||t.vertexPositions;for(let L=0;L<s.length;L+=3)d.push(new se(y[s[L]],y[s[L+1]],y[s[L+2]]));const{tangent:E,bitangent:v}=this.getNormalTangentAndBitangent(d),S=[];for(const L of d)S.push(this.flattenVertex(L,E,v));p=xs.triangulateShape(S,[])}else p=[[0,1,2]];for(const[d,y,E]of p)e.vertex.push(t.vertexPositions[s[d*3]]),e.vertex.push(t.vertexPositions[s[d*3+1]]),e.vertex.push(t.vertexPositions[s[d*3+2]]),e.vertex.push(t.vertexPositions[s[y*3]]),e.vertex.push(t.vertexPositions[s[y*3+1]]),e.vertex.push(t.vertexPositions[s[y*3+2]]),e.vertex.push(t.vertexPositions[s[E*3]]),e.vertex.push(t.vertexPositions[s[E*3+1]]),e.vertex.push(t.vertexPositions[s[E*3+2]]),t.skeleton&&(e.vertexWeights.push(c[d*4]),e.vertexWeights.push(c[d*4+1]),e.vertexWeights.push(c[d*4+2]),e.vertexWeights.push(c[d*4+3]),e.vertexWeights.push(c[y*4]),e.vertexWeights.push(c[y*4+1]),e.vertexWeights.push(c[y*4+2]),e.vertexWeights.push(c[y*4+3]),e.vertexWeights.push(c[E*4]),e.vertexWeights.push(c[E*4+1]),e.vertexWeights.push(c[E*4+2]),e.vertexWeights.push(c[E*4+3]),e.weightsIndices.push(u[d*4]),e.weightsIndices.push(u[d*4+1]),e.weightsIndices.push(u[d*4+2]),e.weightsIndices.push(u[d*4+3]),e.weightsIndices.push(u[y*4]),e.weightsIndices.push(u[y*4+1]),e.weightsIndices.push(u[y*4+2]),e.weightsIndices.push(u[y*4+3]),e.weightsIndices.push(u[E*4]),e.weightsIndices.push(u[E*4+1]),e.weightsIndices.push(u[E*4+2]),e.weightsIndices.push(u[E*4+3])),t.color&&(e.colors.push(i[d*3]),e.colors.push(i[d*3+1]),e.colors.push(i[d*3+2]),e.colors.push(i[y*3]),e.colors.push(i[y*3+1]),e.colors.push(i[y*3+2]),e.colors.push(i[E*3]),e.colors.push(i[E*3+1]),e.colors.push(i[E*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(r[d*3]),e.normal.push(r[d*3+1]),e.normal.push(r[d*3+2]),e.normal.push(r[y*3]),e.normal.push(r[y*3+1]),e.normal.push(r[y*3+2]),e.normal.push(r[E*3]),e.normal.push(r[E*3+1]),e.normal.push(r[E*3+2])),t.uv&&t.uv.forEach(function(v,S){e.uvs[S]===void 0&&(e.uvs[S]=[]),e.uvs[S].push(a[S][d*2]),e.uvs[S].push(a[S][d*2+1]),e.uvs[S].push(a[S][y*2]),e.uvs[S].push(a[S][y*2+1]),e.uvs[S].push(a[S][E*2]),e.uvs[S].push(a[S][E*2+1])})}addMorphTargets(e,t,s,n){if(s.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;s.forEach(function(i){i.rawTargets.forEach(function(a){const c=G.Objects.Geometry[a.geoID];c!==void 0&&r.genMorphGeometry(e,t,c,n,a.name)})})}genMorphGeometry(e,t,s,n,r){const i=t.Vertices!==void 0?t.Vertices.a:[],a=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],c=s.Vertices!==void 0?s.Vertices.a:[],u=s.Indexes!==void 0?s.Indexes.a:[],h=e.attributes.position.count*3,p=new Float32Array(h);for(let v=0;v<u.length;v++){const S=u[v]*3;p[S]=c[v*3],p[S+1]=c[v*3+1],p[S+2]=c[v*3+2]}const d={vertexIndices:a,vertexPositions:p,baseVertexPositions:i},y=this.genBuffers(d),E=new Ee(y.vertex,3);E.name=r||s.attrName,E.applyMatrix4(n),e.morphAttributes.position.push(E)}parseNormals(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Normals.a;let r=[];return s==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:r,mappingType:t,referenceType:s}}parseUVs(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.UV.a;let r=[];return s==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:n,indices:r,mappingType:t,referenceType:s}}parseVertexColors(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Colors.a;let r=[];s==="IndexToDirect"&&(r=e.ColorIndex.a);for(let i=0,a=new ae;i<n.length;i+=4)a.fromArray(n,i),Ae.colorSpaceToWorking(a,te),a.toArray(n,i);return{dataSize:4,buffer:n,indices:r,mappingType:t,referenceType:s}}parseMaterialIndices(e){const t=e.MappingInformationType,s=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:s};const n=e.Materials.a,r=[];for(let i=0;i<n.length;++i)r.push(i);return{dataSize:1,buffer:n,indices:r,mappingType:t,referenceType:s}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new ke;const s=t-1,n=e.KnotVector.a,r=[],i=e.Points.a;for(let p=0,d=i.length;p<d;p+=4)r.push(new As().fromArray(i,p));let a,c;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){a=s,c=n.length-1-a;for(let p=0;p<s;++p)r.push(r[p])}const h=new js(s,n,r,a,c).getPoints(r.length*12);return new ke().setFromPoints(h)}}class Ws{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const s in t){const n=t[s],r=this.addClip(n);e.push(r)}return e}parseClips(){if(G.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=G.Objects.AnimationCurveNode,t=new Map;for(const s in e){const n=e[s];if(n.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:n.id,attr:n.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=G.Objects.AnimationCurve;for(const s in t){const n={id:t[s].id,times:t[s].KeyTime.a.map(Js),values:t[s].KeyValueFloat.a},r=ne.get(n.id);if(r!==void 0){const i=r.parents[0].ID,a=r.parents[0].relationship;a.match(/X/)?e.get(i).curves.x=n:a.match(/Y/)?e.get(i).curves.y=n:a.match(/Z/)?e.get(i).curves.z=n:a.match(/DeformPercent/)&&e.has(i)&&(e.get(i).curves.morph=n)}}}parseAnimationLayers(e){const t=G.Objects.AnimationLayer,s=new Map;for(const n in t){const r=[],i=ne.get(parseInt(n));i!==void 0&&(i.children.forEach(function(c,u){if(e.has(c.ID)){const h=e.get(c.ID);if(h.curves.x!==void 0||h.curves.y!==void 0||h.curves.z!==void 0){if(r[u]===void 0){const p=ne.get(c.ID).parents.filter(function(d){return d.relationship!==void 0})[0].ID;if(p!==void 0){const d=G.Objects.Model[p.toString()];if(d===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",c);return}const y={modelName:d.attrName?at.sanitizeNodeName(d.attrName):"",ID:d.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};pe.traverse(function(E){E.ID===d.id&&(y.transform=E.matrix,E.userData.transformData&&(y.eulerOrder=E.userData.transformData.eulerOrder))}),y.transform||(y.transform=new Q),"PreRotation"in d&&(y.preRotation=d.PreRotation.value),"PostRotation"in d&&(y.postRotation=d.PostRotation.value),r[u]=y}}r[u]&&(r[u][h.attr]=h)}else if(h.curves.morph!==void 0){if(r[u]===void 0){const p=ne.get(c.ID).parents.filter(function(L){return L.relationship!==void 0})[0].ID,d=ne.get(p).parents[0].ID,y=ne.get(d).parents[0].ID,E=ne.get(y).parents[0].ID,v=G.Objects.Model[E],S={modelName:v.attrName?at.sanitizeNodeName(v.attrName):"",morphName:G.Objects.Deformer[p].attrName};r[u]=S}r[u][h.attr]=h}}}),s.set(parseInt(n),r))}return s}parseAnimStacks(e){const t=G.Objects.AnimationStack,s={};for(const n in t){const r=ne.get(parseInt(n)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=e.get(r[0].ID);s[n]={name:t[n].attrName,layer:i}}return s}addClip(e){let t=[];const s=this;return e.layer.forEach(function(n){t=t.concat(s.generateTracks(n))}),new In(e.name,-1,t)}generateTracks(e){const t=[];let s=new se,n=new se;if(e.transform&&e.transform.decompose(s,new Ie,n),s=s.toArray(),n=n.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.T.curves,s,"position");r!==void 0&&t.push(r)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);r!==void 0&&t.push(r)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,n,"scale");r!==void 0&&t.push(r)}if(e.DeformPercent!==void 0){const r=this.generateMorphTrack(e);r!==void 0&&t.push(r)}return t}generateVectorTrack(e,t,s,n){const r=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(r,t,s);return new kt(e+"."+n,r,i)}generateRotationTrack(e,t,s,n,r){let i,a;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const d=this.interpolateRotations(t.x,t.y,t.z,r);i=d[0],a=d[1]}const c=ct(0);s!==void 0&&(s=s.map(he.degToRad),s.push(c),s=new Pe().fromArray(s),s=new Ie().setFromEuler(s)),n!==void 0&&(n=n.map(he.degToRad),n.push(c),n=new Pe().fromArray(n),n=new Ie().setFromEuler(n).invert());const u=new Ie,h=new Pe,p=[];if(!a||!i)return new Tt(e+".quaternion",[0],[0]);for(let d=0;d<a.length;d+=3)h.set(a[d],a[d+1],a[d+2],r),u.setFromEuler(h),s!==void 0&&u.premultiply(s),n!==void 0&&u.multiply(n),d>2&&new Ie().fromArray(p,(d-3)/3*4).dot(u)<0&&u.set(-u.x,-u.y,-u.z,-u.w),u.toArray(p,d/3*4);return new Tt(e+".quaternion",i,p)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,s=t.values.map(function(r){return r/100}),n=pe.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new Nt(e.modelName+".morphTargetInfluences["+n+"]",t.times,s)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(s,n){return s-n}),t.length>1){let s=1,n=t[0];for(let r=1;r<t.length;r++){const i=t[r];i!==n&&(t[s]=i,n=i,s++)}t=t.slice(0,s)}return t}getKeyframeTrackValues(e,t,s){const n=s,r=[];let i=-1,a=-1,c=-1;return e.forEach(function(u){if(t.x&&(i=t.x.times.indexOf(u)),t.y&&(a=t.y.times.indexOf(u)),t.z&&(c=t.z.times.indexOf(u)),i!==-1){const h=t.x.values[i];r.push(h),n[0]=h}else r.push(n[0]);if(a!==-1){const h=t.y.values[a];r.push(h),n[1]=h}else r.push(n[1]);if(c!==-1){const h=t.z.values[c];r.push(h),n[2]=h}else r.push(n[2])}),r}interpolateRotations(e,t,s,n){const r=[],i=[];r.push(e.times[0]),i.push(he.degToRad(e.values[0])),i.push(he.degToRad(t.values[0])),i.push(he.degToRad(s.values[0]));for(let a=1;a<e.values.length;a++){const c=[e.values[a-1],t.values[a-1],s.values[a-1]];if(isNaN(c[0])||isNaN(c[1])||isNaN(c[2]))continue;const u=c.map(he.degToRad),h=[e.values[a],t.values[a],s.values[a]];if(isNaN(h[0])||isNaN(h[1])||isNaN(h[2]))continue;const p=h.map(he.degToRad),d=[h[0]-c[0],h[1]-c[1],h[2]-c[2]],y=[Math.abs(d[0]),Math.abs(d[1]),Math.abs(d[2])];if(y[0]>=180||y[1]>=180||y[2]>=180){const v=Math.max(...y)/180,S=new Pe(...u,n),L=new Pe(...p,n),k=new Ie().setFromEuler(S),F=new Ie().setFromEuler(L);k.dot(F)&&F.set(-F.x,-F.y,-F.z,-F.w);const U=e.times[a-1],Z=e.times[a]-U,j=new Ie,K=new Pe;for(let re=0;re<1;re+=1/v)j.copy(k.clone().slerp(F.clone(),re)),r.push(U+re*Z),K.setFromQuaternion(j,n),i.push(K.x),i.push(K.y),i.push(K.z)}else r.push(e.times[a]),i.push(he.degToRad(e.values[a])),i.push(he.degToRad(t.values[a])),i.push(he.degToRad(s.values[a]))}return[r,i]}}class Ys{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new Ln,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,s=e.split(/[\r\n]+/);return s.forEach(function(n,r){const i=n.match(/^[\s\t]*;/),a=n.match(/^[\s\t]*$/);if(i||a)return;const c=n.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),u=n.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),h=n.match("^\\t{"+(t.currentIndent-1)+"}}");c?t.parseNodeBegin(n,c):u?t.parseNodeProperty(n,u,s[++r]):h?t.popStack():n.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(n)}),this.allNodes}parseNodeBegin(e,t){const s=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map(function(c){return c.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:s},i=this.parseNodeAttr(n),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(s,r):s in a?(s==="PoseNode"?a.PoseNode.push(r):a[s].id!==void 0&&(a[s]={},a[s][a[s].id]=a[s]),i.id!==""&&(a[s][i.id]=r)):typeof i.id=="number"?(a[s]={},a[s][i.id]=r):s!=="Properties70"&&(s==="PoseNode"?a[s]=[r]:a[s]=r),typeof i.id=="number"&&(r.id=i.id),i.name!==""&&(r.attrName=i.name),i.type!==""&&(r.attrType=i.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let s="",n="";return e.length>1&&(s=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:s,type:n}}parseNodeProperty(e,t,s){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();n==="Content"&&r===","&&(r=s.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if(i.name==="Properties70"){this.parseNodeSpecialProperty(e,n,r);return}if(n==="C"){const c=r.split(",").slice(1),u=parseInt(c[0]),h=parseInt(c[1]);let p=r.split(",").slice(3);p=p.map(function(d){return d.trim().replace(/^"/,"")}),n="connections",r=[u,h],tr(r,p),i[n]===void 0&&(i[n]=[])}n==="Node"&&(i.id=r),n in i&&Array.isArray(i[n])?i[n].push(r):n!=="a"?i[n]=r:i.a=r,this.setCurrentProp(i,n),n==="a"&&r.slice(-1)!==","&&(i.a=vt(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=vt(t.a))}parseNodeSpecialProperty(e,t,s){const n=s.split('",').map(function(h){return h.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=n[0],i=n[1],a=n[2],c=n[3];let u=n[4];switch(i){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":u=parseFloat(u);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":u=vt(u);break}this.getPrevNode()[r]={type:i,type2:a,flag:c,value:u},this.setCurrentProp(this.getPrevNode(),r)}}class qs{parse(e){const t=new an(e);t.skip(23);const s=t.getUint32();if(s<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+s);const n=new Ln;for(;!this.endOfContent(t);){const r=this.parseNode(t,s);r!==null&&n.add(r.name,r)}return n}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const s={},n=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const i=e.getUint8(),a=e.getString(i);if(n===0)return null;const c=[];for(let d=0;d<r;d++)c.push(this.parseProperty(e));const u=c.length>0?c[0]:"",h=c.length>1?c[1]:"",p=c.length>2?c[2]:"";for(s.singleProperty=r===1&&e.getOffset()===n;n>e.getOffset();){const d=this.parseNode(e,t);d!==null&&this.parseSubNode(a,s,d)}return s.propertyList=c,typeof u=="number"&&(s.id=u),h!==""&&(s.attrName=h),p!==""&&(s.attrType=p),a!==""&&(s.name=a),s}parseSubNode(e,t,s){if(s.singleProperty===!0){const n=s.propertyList[0];Array.isArray(n)?(t[s.name]=s,s.a=n):t[s.name]=n}else if(e==="Connections"&&s.name==="C"){const n=[];s.propertyList.forEach(function(r,i){i!==0&&n.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(n)}else if(s.name==="Properties70")Object.keys(s).forEach(function(r){t[r]=s[r]});else if(e==="Properties70"&&s.name==="P"){let n=s.propertyList[0],r=s.propertyList[1];const i=s.propertyList[2],a=s.propertyList[3];let c;n.indexOf("Lcl ")===0&&(n=n.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?c=[s.propertyList[4],s.propertyList[5],s.propertyList[6]]:c=s.propertyList[4],t[n]={type:r,type2:i,flag:a,value:c}}else t[s.name]===void 0?typeof s.id=="number"?(t[s.name]={},t[s.name][s.id]=s):t[s.name]=s:s.name==="PoseNode"?(Array.isArray(t[s.name])||(t[s.name]=[t[s.name]]),t[s.name].push(s)):t[s.name][s.id]===void 0&&(t[s.name][s.id]=s)}parseProperty(e){const t=e.getString(1);let s;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return s=e.getUint32(),e.getArrayBuffer(s);case"S":return s=e.getUint32(),e.getString(s);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),r=e.getUint32(),i=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}const a=tt(new Uint8Array(e.getArrayBuffer(i))),c=new an(a.buffer);switch(t){case"b":case"c":return c.getBooleanArray(n);case"d":return c.getFloat64Array(n);case"f":return c.getFloat32Array(n);case"i":return c.getInt32Array(n);case"l":return c.getInt64Array(n)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class an{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let s=0;s<e;s++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let s=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const n=s.indexOf(0);return n>=0&&(s=new Uint8Array(this.dv.buffer,t,n)),this._textDecoder.decode(s)}}class Ln{add(e,t){this[e]=t}}function $s(T){const e="Kaydara FBX Binary  \0";return T.byteLength>=e.length&&e===Cn(T,0,e.length)}function Qs(T){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function s(n){const r=T[n-1];return T=T.slice(t+n),t++,r}for(let n=0;n<e.length;++n)if(s(1)===e[n])return!1;return!0}function cn(T){const e=/FBXVersion: (\d+)/,t=T.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function Js(T){return T/46186158e3}const er=[];function dt(T,e,t,s){let n;switch(s.mappingType){case"ByPolygonVertex":n=T;break;case"ByPolygon":n=e;break;case"ByVertice":n=t;break;case"AllSame":n=s.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+s.mappingType)}s.referenceType==="IndexToDirect"&&(n=s.indices[n]);const r=n*s.dataSize,i=r+s.dataSize;return nr(er,s.buffer,r,i)}const bt=new Pe,He=new se;function Mn(T){const e=new Q,t=new Q,s=new Q,n=new Q,r=new Q,i=new Q,a=new Q,c=new Q,u=new Q,h=new Q,p=new Q,d=new Q,y=T.inheritType?T.inheritType:0;T.translation&&e.setPosition(He.fromArray(T.translation));const E=ct(0);if(T.preRotation){const ce=T.preRotation.map(he.degToRad);ce.push(E),t.makeRotationFromEuler(bt.fromArray(ce))}if(T.rotation){const ce=T.rotation.map(he.degToRad);ce.push(T.eulerOrder||E),s.makeRotationFromEuler(bt.fromArray(ce))}if(T.postRotation){const ce=T.postRotation.map(he.degToRad);ce.push(E),n.makeRotationFromEuler(bt.fromArray(ce)),n.invert()}T.scale&&r.scale(He.fromArray(T.scale)),T.scalingOffset&&a.setPosition(He.fromArray(T.scalingOffset)),T.scalingPivot&&i.setPosition(He.fromArray(T.scalingPivot)),T.rotationOffset&&c.setPosition(He.fromArray(T.rotationOffset)),T.rotationPivot&&u.setPosition(He.fromArray(T.rotationPivot)),T.parentMatrixWorld&&(p.copy(T.parentMatrix),h.copy(T.parentMatrixWorld));const v=t.clone().multiply(s).multiply(n),S=new Q;S.extractRotation(h);const L=new Q;L.copyPosition(h);const k=L.clone().invert().multiply(h),F=S.clone().invert().multiply(k),U=r,Z=new Q;if(y===0)Z.copy(S).multiply(v).multiply(F).multiply(U);else if(y===1)Z.copy(S).multiply(F).multiply(v).multiply(U);else{const de=new Q().scale(new se().setFromMatrixScale(p)).clone().invert(),lt=F.clone().multiply(de);Z.copy(S).multiply(v).multiply(lt).multiply(U)}const j=u.clone().invert(),K=i.clone().invert();let re=e.clone().multiply(c).multiply(u).multiply(t).multiply(s).multiply(n).multiply(j).multiply(a).multiply(i).multiply(r).multiply(K);const fe=new Q().copyPosition(re),xe=h.clone().multiply(fe);return d.copyPosition(xe),re=d.clone().multiply(Z),re.premultiply(h.invert()),re}function ct(T){T=T||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return T===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[T]}function vt(T){return T.split(",").map(function(t){return parseFloat(t)})}function Cn(T,e,t){return e===void 0&&(e=0),t===void 0&&(t=T.byteLength),new TextDecoder().decode(new Uint8Array(T,e,t))}function tr(T,e){for(let t=0,s=T.length,n=e.length;t<n;t++,s++)T[s]=e[t]}function nr(T,e,t,s){for(let n=t,r=0;n<s;n++,r++)T[r]=e[n];return T}const Wr=Object.freeze(Object.defineProperty({__proto__:null,FBXLoader:Xs},Symbol.toStringTag,{value:"Module"}));class sr extends Xe{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new cr(t)}),this.register(function(t){return new lr(t)}),this.register(function(t){return new Tr(t)}),this.register(function(t){return new wr(t)}),this.register(function(t){return new Er(t)}),this.register(function(t){return new hr(t)}),this.register(function(t){return new pr(t)}),this.register(function(t){return new fr(t)}),this.register(function(t){return new dr(t)}),this.register(function(t){return new ar(t)}),this.register(function(t){return new mr(t)}),this.register(function(t){return new ur(t)}),this.register(function(t){return new yr(t)}),this.register(function(t){return new gr(t)}),this.register(function(t){return new ir(t)}),this.register(function(t){return new xr(t)}),this.register(function(t){return new Ar(t)})}load(e,t,s,n){const r=this;let i;if(this.resourcePath!=="")i=this.resourcePath;else if(this.path!==""){const u=je.extractUrlBase(e);i=je.resolveURL(u,this.path)}else i=je.extractUrlBase(e);this.manager.itemStart(e);const a=function(u){n?n(u):console.error(u),r.manager.itemError(e),r.manager.itemEnd(e)},c=new Ke(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(u){try{r.parse(u,i,function(h){t(h),r.manager.itemEnd(e)},a)}catch(h){a(h)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let r;const i={},a={},c=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(c.decode(new Uint8Array(e,0,4))===On){try{i[V.KHR_BINARY_GLTF]=new Sr(e)}catch(p){n&&n(p);return}r=JSON.parse(i[V.KHR_BINARY_GLTF].content)}else r=JSON.parse(c.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const u=new kr(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});u.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const p=this.pluginCallbacks[h](u);p.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[p.name]=p,i[p.name]=!0}if(r.extensionsUsed)for(let h=0;h<r.extensionsUsed.length;++h){const p=r.extensionsUsed[h],d=r.extensionsRequired||[];switch(p){case V.KHR_MATERIALS_UNLIT:i[p]=new or;break;case V.KHR_DRACO_MESH_COMPRESSION:i[p]=new Ir(r,this.dracoLoader);break;case V.KHR_TEXTURE_TRANSFORM:i[p]=new Rr;break;case V.KHR_MESH_QUANTIZATION:i[p]=new br;break;default:d.indexOf(p)>=0&&a[p]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+p+'".')}}u.setExtensions(i),u.setPlugins(a),u.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,r){s.parse(e,t,n,r)})}}function rr(){let T={};return{get:function(e){return T[e]},add:function(e,t){T[e]=t},remove:function(e){delete T[e]},removeAll:function(){T={}}}}const V={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class ir{constructor(e){this.parser=e,this.name=V.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const r=t[s];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const r=t.json,c=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let u;const h=new ae(16777215);c.color!==void 0&&h.setRGB(c.color[0],c.color[1],c.color[2],le);const p=c.range!==void 0?c.range:0;switch(c.type){case"directional":u=new En(h),u.target.position.set(0,0,-1),u.add(u.target);break;case"point":u=new Pt(h),u.distance=p;break;case"spot":u=new wn(h),u.distance=p,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,u.angle=c.spot.outerConeAngle,u.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,u.target.position.set(0,0,-1),u.add(u.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return u.position.set(0,0,0),Re(u,c),c.intensity!==void 0&&(u.intensity=c.intensity),u.name=t.createUniqueName(c.name||"light_"+e),n=Promise.resolve(u),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,r=s.json.nodes[e],a=(r.extensions&&r.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(c){return s._getNodeRef(t.cache,a,c)})}}class or{constructor(){this.name=V.KHR_MATERIALS_UNLIT}getMaterialType(){return et}extendParams(e,t,s){const n=[];e.color=new ae(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const i=r.baseColorFactor;e.color.setRGB(i[0],i[1],i[2],le),e.opacity=i[3]}r.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",r.baseColorTexture,te))}return Promise.all(n)}}class ar{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class cr{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];if(i.clearcoatFactor!==void 0&&(t.clearcoat=i.clearcoatFactor),i.clearcoatTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatMap",i.clearcoatTexture)),i.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=i.clearcoatRoughnessFactor),i.clearcoatRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",i.clearcoatRoughnessTexture)),i.clearcoatNormalTexture!==void 0&&(r.push(s.assignTexture(t,"clearcoatNormalMap",i.clearcoatNormalTexture)),i.clearcoatNormalTexture.scale!==void 0)){const a=i.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Gt(a,a)}return Promise.all(r)}}class lr{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class ur{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.iridescenceFactor!==void 0&&(t.iridescence=i.iridescenceFactor),i.iridescenceTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceMap",i.iridescenceTexture)),i.iridescenceIor!==void 0&&(t.iridescenceIOR=i.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),i.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=i.iridescenceThicknessMinimum),i.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=i.iridescenceThicknessMaximum),i.iridescenceThicknessTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceThicknessMap",i.iridescenceThicknessTexture)),Promise.all(r)}}class hr{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new ae(0,0,0),t.sheenRoughness=0,t.sheen=1;const i=n.extensions[this.name];if(i.sheenColorFactor!==void 0){const a=i.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],le)}return i.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=i.sheenRoughnessFactor),i.sheenColorTexture!==void 0&&r.push(s.assignTexture(t,"sheenColorMap",i.sheenColorTexture,te)),i.sheenRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"sheenRoughnessMap",i.sheenRoughnessTexture)),Promise.all(r)}}class pr{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.transmissionFactor!==void 0&&(t.transmission=i.transmissionFactor),i.transmissionTexture!==void 0&&r.push(s.assignTexture(t,"transmissionMap",i.transmissionTexture)),Promise.all(r)}}class fr{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.thickness=i.thicknessFactor!==void 0?i.thicknessFactor:0,i.thicknessTexture!==void 0&&r.push(s.assignTexture(t,"thicknessMap",i.thicknessTexture)),t.attenuationDistance=i.attenuationDistance||1/0;const a=i.attenuationColor||[1,1,1];return t.attenuationColor=new ae().setRGB(a[0],a[1],a[2],le),Promise.all(r)}}class dr{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class mr{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.specularIntensity=i.specularFactor!==void 0?i.specularFactor:1,i.specularTexture!==void 0&&r.push(s.assignTexture(t,"specularIntensityMap",i.specularTexture));const a=i.specularColorFactor||[1,1,1];return t.specularColor=new ae().setRGB(a[0],a[1],a[2],le),i.specularColorTexture!==void 0&&r.push(s.assignTexture(t,"specularColorMap",i.specularColorTexture,te)),Promise.all(r)}}class gr{constructor(e){this.parser=e,this.name=V.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return t.bumpScale=i.bumpFactor!==void 0?i.bumpFactor:1,i.bumpTexture!==void 0&&r.push(s.assignTexture(t,"bumpMap",i.bumpTexture)),Promise.all(r)}}class yr{constructor(e){this.parser=e,this.name=V.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:be}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.anisotropyStrength!==void 0&&(t.anisotropy=i.anisotropyStrength),i.anisotropyRotation!==void 0&&(t.anisotropyRotation=i.anisotropyRotation),i.anisotropyTexture!==void 0&&r.push(s.assignTexture(t,"anisotropyMap",i.anisotropyTexture)),Promise.all(r)}}class Tr{constructor(e){this.parser=e,this.name=V.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],i=t.options.ktx2Loader;if(!i){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,i)}}class wr{constructor(e){this.parser=e,this.name=V.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],a=n.images[i.source];let c=s.textureLoader;if(a.uri){const u=s.options.manager.getHandler(a.uri);u!==null&&(c=u)}return s.loadTextureImage(e,i.source,c)}}class Er{constructor(e){this.parser=e,this.name=V.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],a=n.images[i.source];let c=s.textureLoader;if(a.uri){const u=s.options.manager.getHandler(a.uri);u!==null&&(c=u)}return s.loadTextureImage(e,i.source,c)}}class xr{constructor(e){this.name=V.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],r=this.parser.getDependency("buffer",n.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(a){const c=n.byteOffset||0,u=n.byteLength||0,h=n.count,p=n.byteStride,d=new Uint8Array(a,c,u);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(h,p,d,n.mode,n.filter).then(function(y){return y.buffer}):i.ready.then(function(){const y=new ArrayBuffer(h*p);return i.decodeGltfBuffer(new Uint8Array(y),h,p,d,n.mode,n.filter),y})})}else return null}}class Ar{constructor(e){this.name=V.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const u of n.primitives)if(u.mode!==we.TRIANGLES&&u.mode!==we.TRIANGLE_STRIP&&u.mode!==we.TRIANGLE_FAN&&u.mode!==void 0)return null;const i=s.extensions[this.name].attributes,a=[],c={};for(const u in i)a.push(this.parser.getDependency("accessor",i[u]).then(h=>(c[u]=h,c[u])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(u=>{const h=u.pop(),p=h.isGroup?h.children:[h],d=u[0].count,y=[];for(const E of p){const v=new Q,S=new se,L=new Ie,k=new se(1,1,1),F=new Ss(E.geometry,E.material,d);for(let U=0;U<d;U++)c.TRANSLATION&&S.fromBufferAttribute(c.TRANSLATION,U),c.ROTATION&&L.fromBufferAttribute(c.ROTATION,U),c.SCALE&&k.fromBufferAttribute(c.SCALE,U),F.setMatrixAt(U,v.compose(S,L,k));for(const U in c)if(U==="_COLOR_0"){const Z=c[U];F.instanceColor=new Is(Z.array,Z.itemSize,Z.normalized)}else U!=="TRANSLATION"&&U!=="ROTATION"&&U!=="SCALE"&&E.geometry.setAttribute(U,c[U]);Ge.prototype.copy.call(F,E),this.parser.assignFinalMaterial(F),y.push(F)}return h.isGroup?(h.clear(),h.add(...y),h):y[0]}))}}const On="glTF",$e=12,ln={JSON:1313821514,BIN:5130562};class Sr{constructor(e){this.name=V.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,$e),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==On)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-$e,r=new DataView(e,$e);let i=0;for(;i<n;){const a=r.getUint32(i,!0);i+=4;const c=r.getUint32(i,!0);if(i+=4,c===ln.JSON){const u=new Uint8Array(e,$e+i,a);this.content=s.decode(u)}else if(c===ln.BIN){const u=$e+i;this.body=e.slice(u,u+a)}i+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Ir{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=V.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,i=e.extensions[this.name].attributes,a={},c={},u={};for(const h in i){const p=Bt[h]||h.toLowerCase();a[p]=i[h]}for(const h in e.attributes){const p=Bt[h]||h.toLowerCase();if(i[h]!==void 0){const d=s.accessors[e.attributes[h]],y=ze[d.componentType];u[p]=y.name,c[p]=d.normalized===!0}}return t.getDependency("bufferView",r).then(function(h){return new Promise(function(p,d){n.decodeDracoFile(h,function(y){for(const E in y.attributes){const v=y.attributes[E],S=c[E];S!==void 0&&(v.normalized=S)}p(y)},a,u,le,d)})})}}class Rr{constructor(){this.name=V.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class br{constructor(){this.name=V.KHR_MESH_QUANTIZATION}}class Fn extends Ns{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let i=0;i!==n;i++)t[i]=s[r+i];return t}interpolate_(e,t,s,n){const r=this.resultBuffer,i=this.sampleValues,a=this.valueSize,c=a*2,u=a*3,h=n-t,p=(s-t)/h,d=p*p,y=d*p,E=e*u,v=E-u,S=-2*y+3*d,L=y-d,k=1-S,F=L-d+p;for(let U=0;U!==a;U++){const Z=i[v+U+a],j=i[v+U+c]*h,K=i[E+U+a],re=i[E+U]*h;r[U]=k*Z+F*j+S*K+L*re}return r}}const vr=new Ie;class _r extends Fn{interpolate_(e,t,s,n){const r=super.interpolate_(e,t,s,n);return vr.fromArray(r).normalize().toArray(r),r}}const we={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},ze={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},un={9728:bn,9729:it,9984:Ls,9985:_s,9986:vs,9987:Rn},hn={33071:Ot,33648:Ms,10497:ot},_t={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Bt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Oe={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Lr={CUBICSPLINE:void 0,LINEAR:_n,STEP:Ds},Lt={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Mr(T){return T.DefaultMaterial===void 0&&(T.DefaultMaterial=new vn({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ks})),T.DefaultMaterial}function De(T,e,t){for(const s in t.extensions)T[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function Re(T,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(T.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Cr(T,e,t){let s=!1,n=!1,r=!1;for(let u=0,h=e.length;u<h;u++){const p=e[u];if(p.POSITION!==void 0&&(s=!0),p.NORMAL!==void 0&&(n=!0),p.COLOR_0!==void 0&&(r=!0),s&&n&&r)break}if(!s&&!n&&!r)return Promise.resolve(T);const i=[],a=[],c=[];for(let u=0,h=e.length;u<h;u++){const p=e[u];if(s){const d=p.POSITION!==void 0?t.getDependency("accessor",p.POSITION):T.attributes.position;i.push(d)}if(n){const d=p.NORMAL!==void 0?t.getDependency("accessor",p.NORMAL):T.attributes.normal;a.push(d)}if(r){const d=p.COLOR_0!==void 0?t.getDependency("accessor",p.COLOR_0):T.attributes.color;c.push(d)}}return Promise.all([Promise.all(i),Promise.all(a),Promise.all(c)]).then(function(u){const h=u[0],p=u[1],d=u[2];return s&&(T.morphAttributes.position=h),n&&(T.morphAttributes.normal=p),r&&(T.morphAttributes.color=d),T.morphTargetsRelative=!0,T})}function Or(T,e){if(T.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)T.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(T.morphTargetInfluences.length===t.length){T.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)T.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Fr(T){let e;const t=T.extensions&&T.extensions[V.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Mt(t.attributes):e=T.indices+":"+Mt(T.attributes)+":"+T.mode,T.targets!==void 0)for(let s=0,n=T.targets.length;s<n;s++)e+=":"+Mt(T.targets[s]);return e}function Mt(T){let e="";const t=Object.keys(T).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+T[t[s]]+";";return e}function Ht(T){switch(T){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Dr(T){return T.search(/\.jpe?g($|\?)/i)>0||T.search(/^data\:image\/jpeg/)===0?"image/jpeg":T.search(/\.webp($|\?)/i)>0||T.search(/^data\:image\/webp/)===0?"image/webp":T.search(/\.ktx2($|\?)/i)>0||T.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const Pr=new Q;class kr{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new rr,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,r=!1,i=-1;if(typeof navigator<"u"){const a=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(a)===!0;const c=a.match(/Version\/(\d+)/);n=s&&c?parseInt(c[1],10):-1,r=a.indexOf("Firefox")>-1,i=r?a.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||s&&n<17||r&&i<98?this.textureLoader=new yn(this.options.manager):this.textureLoader=new Rs(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Ke(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(i){return i._markDefs&&i._markDefs()}),Promise.all(this._invokeAll(function(i){return i.beforeRoot&&i.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(i){const a={scene:i[0][n.scene||0],scenes:i[0],animations:i[1],cameras:i[2],asset:n.asset,parser:s,userData:{}};return De(r,a,n),Re(a,n),Promise.all(s._invokeAll(function(c){return c.afterRoot&&c.afterRoot(a)})).then(function(){for(const c of a.scenes)c.updateMatrixWorld();e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const i=t[n].joints;for(let a=0,c=i.length;a<c;a++)e[i[a]].isBone=!0}for(let n=0,r=e.length;n<r;n++){const i=e[n];i.mesh!==void 0&&(this._addNodeRef(this.meshCache,i.mesh),i.skin!==void 0&&(s[i.mesh].isSkinnedMesh=!0)),i.camera!==void 0&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),r=(i,a)=>{const c=this.associations.get(i);c!=null&&this.associations.set(a,c);for(const[u,h]of i.children.entries())r(h,a.children[u])};return r(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const r=e(t[n]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":n=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(r,i){return s.getDependency(e,i)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[V.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(r,i){s.load(je.resolveURL(t.uri,n.path),r,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,r=t.byteOffset||0;return s.slice(r,r+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const i=_t[n.type],a=ze[n.componentType],c=n.normalized===!0,u=new a(n.count*i);return Promise.resolve(new nt(u,i,c))}const r=[];return n.bufferView!==void 0?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),n.sparse!==void 0&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then(function(i){const a=i[0],c=_t[n.type],u=ze[n.componentType],h=u.BYTES_PER_ELEMENT,p=h*c,d=n.byteOffset||0,y=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,E=n.normalized===!0;let v,S;if(y&&y!==p){const L=Math.floor(d/y),k="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+L+":"+n.count;let F=t.cache.get(k);F||(v=new u(a,L*y,n.count*y/h),F=new bs(v,y/h),t.cache.add(k,F)),S=new Ps(F,c,d%y/h,E)}else a===null?v=new u(n.count*c):v=new u(a,d,n.count*c),S=new nt(v,c,E);if(n.sparse!==void 0){const L=_t.SCALAR,k=ze[n.sparse.indices.componentType],F=n.sparse.indices.byteOffset||0,U=n.sparse.values.byteOffset||0,Z=new k(i[1],F,n.sparse.count*L),j=new u(i[2],U,n.sparse.count*c);a!==null&&(S=new nt(S.array.slice(),S.itemSize,S.normalized)),S.normalized=!1;for(let K=0,re=Z.length;K<re;K++){const fe=Z[K];if(S.setX(fe,j[K*c]),c>=2&&S.setY(fe,j[K*c+1]),c>=3&&S.setZ(fe,j[K*c+2]),c>=4&&S.setW(fe,j[K*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}S.normalized=E}return S})}loadTexture(e){const t=this.json,s=this.options,r=t.textures[e].source,i=t.images[r];let a=this.textureLoader;if(i.uri){const c=s.manager.getHandler(i.uri);c!==null&&(a=c)}return this.loadTextureImage(e,r,a)}loadTextureImage(e,t,s){const n=this,r=this.json,i=r.textures[e],a=r.images[t],c=(a.uri||a.bufferView)+":"+i.sampler;if(this.textureCache[c])return this.textureCache[c];const u=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=i.name||a.name||"",h.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(h.name=a.uri);const d=(r.samplers||{})[i.sampler]||{};return h.magFilter=un[d.magFilter]||it,h.minFilter=un[d.minFilter]||Rn,h.wrapS=hn[d.wrapS]||ot,h.wrapT=hn[d.wrapT]||ot,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==bn&&h.minFilter!==it,n.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[c]=u,u}loadImageSource(e,t){const s=this,n=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(p=>p.clone());const i=n.images[e],a=self.URL||self.webkitURL;let c=i.uri||"",u=!1;if(i.bufferView!==void 0)c=s.getDependency("bufferView",i.bufferView).then(function(p){u=!0;const d=new Blob([p],{type:i.mimeType});return c=a.createObjectURL(d),c});else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(c).then(function(p){return new Promise(function(d,y){let E=d;t.isImageBitmapLoader===!0&&(E=function(v){const S=new Ft(v);S.needsUpdate=!0,d(S)}),t.load(je.resolveURL(p,r.path),E,void 0,y)})}).then(function(p){return u===!0&&a.revokeObjectURL(c),Re(p,i),p.userData.mimeType=i.mimeType||Dr(i.uri),p}).catch(function(p){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),p});return this.sourceCache[e]=h,h}assignTexture(e,t,s,n){const r=this;return this.getDependency("texture",s.index).then(function(i){if(!i)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(i=i.clone(),i.channel=s.texCoord),r.extensions[V.KHR_TEXTURE_TRANSFORM]){const a=s.extensions!==void 0?s.extensions[V.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const c=r.associations.get(i);i=r.extensions[V.KHR_TEXTURE_TRANSFORM].extendTexture(i,a),r.associations.set(i,c)}}return n!==void 0&&(i.colorSpace=n),e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,i=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let c=this.cache.get(a);c||(c=new Je,rt.prototype.copy.call(c,s),c.color.copy(s.color),c.map=s.map,c.sizeAttenuation=!1,this.cache.add(a,c)),s=c}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let c=this.cache.get(a);c||(c=new st,rt.prototype.copy.call(c,s),c.color.copy(s.color),c.map=s.map,this.cache.add(a,c)),s=c}if(n||r||i){let a="ClonedMaterial:"+s.uuid+":";n&&(a+="derivative-tangents:"),r&&(a+="vertex-colors:"),i&&(a+="flat-shading:");let c=this.cache.get(a);c||(c=s.clone(),r&&(c.vertexColors=!0),i&&(c.flatShading=!0),n&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(a,c),this.associations.set(c,this.associations.get(s))),s=c}e.material=s}getMaterialType(){return vn}loadMaterial(e){const t=this,s=this.json,n=this.extensions,r=s.materials[e];let i;const a={},c=r.extensions||{},u=[];if(c[V.KHR_MATERIALS_UNLIT]){const p=n[V.KHR_MATERIALS_UNLIT];i=p.getMaterialType(),u.push(p.extendParams(a,r,t))}else{const p=r.pbrMetallicRoughness||{};if(a.color=new ae(1,1,1),a.opacity=1,Array.isArray(p.baseColorFactor)){const d=p.baseColorFactor;a.color.setRGB(d[0],d[1],d[2],le),a.opacity=d[3]}p.baseColorTexture!==void 0&&u.push(t.assignTexture(a,"map",p.baseColorTexture,te)),a.metalness=p.metallicFactor!==void 0?p.metallicFactor:1,a.roughness=p.roughnessFactor!==void 0?p.roughnessFactor:1,p.metallicRoughnessTexture!==void 0&&(u.push(t.assignTexture(a,"metalnessMap",p.metallicRoughnessTexture)),u.push(t.assignTexture(a,"roughnessMap",p.metallicRoughnessTexture))),i=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),u.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}r.doubleSided===!0&&(a.side=Cs);const h=r.alphaMode||Lt.OPAQUE;if(h===Lt.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,h===Lt.MASK&&(a.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&i!==et&&(u.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new Gt(1,1),r.normalTexture.scale!==void 0)){const p=r.normalTexture.scale;a.normalScale.set(p,p)}if(r.occlusionTexture!==void 0&&i!==et&&(u.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&i!==et){const p=r.emissiveFactor;a.emissive=new ae().setRGB(p[0],p[1],p[2],le)}return r.emissiveTexture!==void 0&&i!==et&&u.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,te)),Promise.all(u).then(function(){const p=new i(a);return r.name&&(p.name=r.name),Re(p,r),t.associations.set(p,{materials:e}),r.extensions&&De(n,p,r),p})}createUniqueName(e){const t=at.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function r(a){return s[V.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(c){return pn(c,a,t)})}const i=[];for(let a=0,c=e.length;a<c;a++){const u=e[a],h=Fr(u),p=n[h];if(p)i.push(p.promise);else{let d;u.extensions&&u.extensions[V.KHR_DRACO_MESH_COMPRESSION]?d=r(u):d=pn(new ke,u,t),n[h]={primitive:u,promise:d},i.push(d)}}return Promise.all(i)}loadMesh(e){const t=this,s=this.json,n=this.extensions,r=s.meshes[e],i=r.primitives,a=[];for(let c=0,u=i.length;c<u;c++){const h=i[c].material===void 0?Mr(this.cache):this.getDependency("material",i[c].material);a.push(h)}return a.push(t.loadGeometries(i)),Promise.all(a).then(function(c){const u=c.slice(0,c.length-1),h=c[c.length-1],p=[];for(let y=0,E=h.length;y<E;y++){const v=h[y],S=i[y];let L;const k=u[y];if(S.mode===we.TRIANGLES||S.mode===we.TRIANGLE_STRIP||S.mode===we.TRIANGLE_FAN||S.mode===void 0)L=r.isSkinnedMesh===!0?new xn(v,k):new yt(v,k),L.isSkinnedMesh===!0&&L.normalizeSkinWeights(),S.mode===we.TRIANGLE_STRIP?L.geometry=on(L.geometry,Hs):S.mode===we.TRIANGLE_FAN&&(L.geometry=on(L.geometry,Gs));else if(S.mode===we.LINES)L=new Ut(v,k);else if(S.mode===we.LINE_STRIP)L=new An(v,k);else if(S.mode===we.LINE_LOOP)L=new Os(v,k);else if(S.mode===we.POINTS)L=new gt(v,k);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+S.mode);Object.keys(L.geometry.morphAttributes).length>0&&Or(L,r),L.name=t.createUniqueName(r.name||"mesh_"+e),Re(L,r),S.extensions&&De(n,L,S),t.assignFinalMaterial(L),p.push(L)}for(let y=0,E=p.length;y<E;y++)t.associations.set(p[y],{meshes:e,primitives:y});if(p.length===1)return r.extensions&&De(n,p[0],r),p[0];const d=new Ve;r.extensions&&De(n,d,r),t.associations.set(d,{meshes:e});for(let y=0,E=p.length;y<E;y++)d.add(p[y]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new Tn(he.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new Fs(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),Re(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,r=t.joints.length;n<r;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const r=n.pop(),i=n,a=[],c=[];for(let u=0,h=i.length;u<h;u++){const p=i[u];if(p){a.push(p);const d=new Q;r!==null&&d.fromArray(r.array,u*16),c.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[u])}return new Sn(a,c)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],r=n.name?n.name:"animation_"+e,i=[],a=[],c=[],u=[],h=[];for(let p=0,d=n.channels.length;p<d;p++){const y=n.channels[p],E=n.samplers[y.sampler],v=y.target,S=v.node,L=n.parameters!==void 0?n.parameters[E.input]:E.input,k=n.parameters!==void 0?n.parameters[E.output]:E.output;v.node!==void 0&&(i.push(this.getDependency("node",S)),a.push(this.getDependency("accessor",L)),c.push(this.getDependency("accessor",k)),u.push(E),h.push(v))}return Promise.all([Promise.all(i),Promise.all(a),Promise.all(c),Promise.all(u),Promise.all(h)]).then(function(p){const d=p[0],y=p[1],E=p[2],v=p[3],S=p[4],L=[];for(let F=0,U=d.length;F<U;F++){const Z=d[F],j=y[F],K=E[F],re=v[F],fe=S[F];if(Z===void 0)continue;Z.updateMatrix&&Z.updateMatrix();const xe=s._createAnimationTracks(Z,j,K,re,fe);if(xe)for(let ce=0;ce<xe.length;ce++)L.push(xe[ce])}const k=new In(r,void 0,L);return Re(k,n),k})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(r){const i=s._getNodeRef(s.meshCache,n.mesh,r);return n.weights!==void 0&&i.traverse(function(a){if(a.isMesh)for(let c=0,u=n.weights.length;c<u;c++)a.morphTargetInfluences[c]=n.weights[c]}),i})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],r=s._loadNodeShallow(e),i=[],a=n.children||[];for(let u=0,h=a.length;u<h;u++)i.push(s.getDependency("node",a[u]));const c=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([r,Promise.all(i),c]).then(function(u){const h=u[0],p=u[1],d=u[2];d!==null&&h.traverse(function(y){y.isSkinnedMesh&&y.bind(d,Pr)});for(let y=0,E=p.length;y<E;y++)h.add(p[y]);return h})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],i=r.name?n.createUniqueName(r.name):"",a=[],c=n._invokeOne(function(u){return u.createNodeMesh&&u.createNodeMesh(e)});return c&&a.push(c),r.camera!==void 0&&a.push(n.getDependency("camera",r.camera).then(function(u){return n._getNodeRef(n.cameraCache,r.camera,u)})),n._invokeAll(function(u){return u.createNodeAttachment&&u.createNodeAttachment(e)}).forEach(function(u){a.push(u)}),this.nodeCache[e]=Promise.all(a).then(function(u){let h;if(r.isBone===!0?h=new Dt:u.length>1?h=new Ve:u.length===1?h=u[0]:h=new Ge,h!==u[0])for(let p=0,d=u.length;p<d;p++)h.add(u[p]);if(r.name&&(h.userData.name=r.name,h.name=i),Re(h,r),r.extensions&&De(s,h,r),r.matrix!==void 0){const p=new Q;p.fromArray(r.matrix),h.applyMatrix4(p)}else r.translation!==void 0&&h.position.fromArray(r.translation),r.rotation!==void 0&&h.quaternion.fromArray(r.rotation),r.scale!==void 0&&h.scale.fromArray(r.scale);if(!n.associations.has(h))n.associations.set(h,{});else if(r.mesh!==void 0&&n.meshCache.refs[r.mesh]>1){const p=n.associations.get(h);n.associations.set(h,{...p})}return n.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,r=new Ve;s.name&&(r.name=n.createUniqueName(s.name)),Re(r,s),s.extensions&&De(t,r,s);const i=s.nodes||[],a=[];for(let c=0,u=i.length;c<u;c++)a.push(n.getDependency("node",i[c]));return Promise.all(a).then(function(c){for(let h=0,p=c.length;h<p;h++)r.add(c[h]);const u=h=>{const p=new Map;for(const[d,y]of n.associations)(d instanceof rt||d instanceof Ft)&&p.set(d,y);return h.traverse(d=>{const y=n.associations.get(d);y!=null&&p.set(d,y)}),p};return n.associations=u(r),r})}_createAnimationTracks(e,t,s,n,r){const i=[],a=e.name?e.name:e.uuid,c=[];Oe[r.path]===Oe.weights?e.traverse(function(d){d.morphTargetInfluences&&c.push(d.name?d.name:d.uuid)}):c.push(a);let u;switch(Oe[r.path]){case Oe.weights:u=Nt;break;case Oe.rotation:u=Tt;break;case Oe.translation:case Oe.scale:u=kt;break;default:switch(s.itemSize){case 1:u=Nt;break;case 2:case 3:default:u=kt;break}break}const h=n.interpolation!==void 0?Lr[n.interpolation]:_n,p=this._getArrayFromAccessor(s);for(let d=0,y=c.length;d<y;d++){const E=new u(c[d]+"."+Oe[r.path],t.array,p,h);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(E),i.push(E)}return i}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=Ht(t.constructor),n=new Float32Array(t.length);for(let r=0,i=t.length;r<i;r++)n[r]=t[r]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof Tt?_r:Fn;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Nr(T,e,t){const s=e.attributes,n=new Us;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],c=a.min,u=a.max;if(c!==void 0&&u!==void 0){if(n.set(new se(c[0],c[1],c[2]),new se(u[0],u[1],u[2])),a.normalized){const h=Ht(ze[a.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const a=new se,c=new se;for(let u=0,h=r.length;u<h;u++){const p=r[u];if(p.POSITION!==void 0){const d=t.json.accessors[p.POSITION],y=d.min,E=d.max;if(y!==void 0&&E!==void 0){if(c.setX(Math.max(Math.abs(y[0]),Math.abs(E[0]))),c.setY(Math.max(Math.abs(y[1]),Math.abs(E[1]))),c.setZ(Math.max(Math.abs(y[2]),Math.abs(E[2]))),d.normalized){const v=Ht(ze[d.componentType]);c.multiplyScalar(v)}a.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(a)}T.boundingBox=n;const i=new Bs;n.getCenter(i.center),i.radius=n.min.distanceTo(n.max)/2,T.boundingSphere=i}function pn(T,e,t){const s=e.attributes,n=[];function r(i,a){return t.getDependency("accessor",i).then(function(c){T.setAttribute(a,c)})}for(const i in s){const a=Bt[i]||i.toLowerCase();a in T.attributes||n.push(r(s[i],a))}if(e.indices!==void 0&&!T.index){const i=t.getDependency("accessor",e.indices).then(function(a){T.setIndex(a)});n.push(i)}return Ae.workingColorSpace!==le&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ae.workingColorSpace}" not supported.`),Re(T,e),Nr(T,e,t),Promise.all(n).then(function(){return e.targets!==void 0?Cr(T,e.targets,t):T})}const Yr=Object.freeze(Object.defineProperty({__proto__:null,GLTFLoader:sr},Symbol.toStringTag,{value:"Module"})),Ur=/^[og]\s*(.+)?/,Br=/^mtllib /,Hr=/^usemtl /,Gr=/^usemap /,fn=/\s+/,dn=new se,Ct=new se,mn=new se,gn=new se,Te=new se,mt=new ae;function jr(){const T={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=e,this.object.fromDeclaration=t!==!1;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(n,r){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const a={index:this.materials.length,name:n||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:i!==void 0?i.smooth:this.smooth,groupStart:i!==void 0?i.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(c){const u={index:typeof c=="number"?c:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return u.clone=this.clone.bind(u),u}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(n){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),n&&this.materials.length>1)for(let i=this.materials.length-1;i>=0;i--)this.materials[i].groupCount<=0&&this.materials.splice(i,1);return n&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},s&&s.name&&typeof s.clone=="function"){const n=s.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/3)*3},parseNormalIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/3)*3},parseUVIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/2)*2},addVertex:function(e,t,s){const n=this.vertices,r=this.object.geometry.vertices;r.push(n[e+0],n[e+1],n[e+2]),r.push(n[t+0],n[t+1],n[t+2]),r.push(n[s+0],n[s+1],n[s+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,s){const n=this.normals,r=this.object.geometry.normals;r.push(n[e+0],n[e+1],n[e+2]),r.push(n[t+0],n[t+1],n[t+2]),r.push(n[s+0],n[s+1],n[s+2])},addFaceNormal:function(e,t,s){const n=this.vertices,r=this.object.geometry.normals;dn.fromArray(n,e),Ct.fromArray(n,t),mn.fromArray(n,s),Te.subVectors(mn,Ct),gn.subVectors(dn,Ct),Te.cross(gn),Te.normalize(),r.push(Te.x,Te.y,Te.z),r.push(Te.x,Te.y,Te.z),r.push(Te.x,Te.y,Te.z)},addColor:function(e,t,s){const n=this.colors,r=this.object.geometry.colors;n[e]!==void 0&&r.push(n[e+0],n[e+1],n[e+2]),n[t]!==void 0&&r.push(n[t+0],n[t+1],n[t+2]),n[s]!==void 0&&r.push(n[s+0],n[s+1],n[s+2])},addUV:function(e,t,s){const n=this.uvs,r=this.object.geometry.uvs;r.push(n[e+0],n[e+1]),r.push(n[t+0],n[t+1]),r.push(n[s+0],n[s+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,s,n,r,i,a,c,u){const h=this.vertices.length;let p=this.parseVertexIndex(e,h),d=this.parseVertexIndex(t,h),y=this.parseVertexIndex(s,h);if(this.addVertex(p,d,y),this.addColor(p,d,y),a!==void 0&&a!==""){const E=this.normals.length;p=this.parseNormalIndex(a,E),d=this.parseNormalIndex(c,E),y=this.parseNormalIndex(u,E),this.addNormal(p,d,y)}else this.addFaceNormal(p,d,y);if(n!==void 0&&n!==""){const E=this.uvs.length;p=this.parseUVIndex(n,E),d=this.parseUVIndex(r,E),y=this.parseUVIndex(i,E),this.addUV(p,d,y),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let s=0,n=e.length;s<n;s++){const r=this.parseVertexIndex(e[s],t);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const s=this.vertices.length,n=this.uvs.length;for(let r=0,i=e.length;r<i;r++)this.addVertexLine(this.parseVertexIndex(e[r],s));for(let r=0,i=t.length;r<i;r++)this.addUVLine(this.parseUVIndex(t[r],n))}};return T.startObject("",!1),T}class Vr extends Xe{constructor(e){super(e),this.materials=null}load(e,t,s,n){const r=this,i=new Ke(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,function(a){try{t(r.parse(a))}catch(c){n?n(c):console.error(c),r.manager.itemError(e)}},s,n)}setMaterials(e){return this.materials=e,this}parse(e){const t=new jr;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const s=e.split(`
`);let n=[];for(let a=0,c=s.length;a<c;a++){const u=s[a].trimStart();if(u.length===0)continue;const h=u.charAt(0);if(h!=="#")if(h==="v"){const p=u.split(fn);switch(p[0]){case"v":t.vertices.push(parseFloat(p[1]),parseFloat(p[2]),parseFloat(p[3])),p.length>=7?(mt.setRGB(parseFloat(p[4]),parseFloat(p[5]),parseFloat(p[6]),te),t.colors.push(mt.r,mt.g,mt.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(p[1]),parseFloat(p[2]),parseFloat(p[3]));break;case"vt":t.uvs.push(parseFloat(p[1]),parseFloat(p[2]));break}}else if(h==="f"){const d=u.slice(1).trim().split(fn),y=[];for(let v=0,S=d.length;v<S;v++){const L=d[v];if(L.length>0){const k=L.split("/");y.push(k)}}const E=y[0];for(let v=1,S=y.length-1;v<S;v++){const L=y[v],k=y[v+1];t.addFace(E[0],L[0],k[0],E[1],L[1],k[1],E[2],L[2],k[2])}}else if(h==="l"){const p=u.substring(1).trim().split(" ");let d=[];const y=[];if(u.indexOf("/")===-1)d=p;else for(let E=0,v=p.length;E<v;E++){const S=p[E].split("/");S[0]!==""&&d.push(S[0]),S[1]!==""&&y.push(S[1])}t.addLineGeometry(d,y)}else if(h==="p"){const d=u.slice(1).trim().split(" ");t.addPointGeometry(d)}else if((n=Ur.exec(u))!==null){const p=(" "+n[0].slice(1).trim()).slice(1);t.startObject(p)}else if(Hr.test(u))t.object.startMaterial(u.substring(7).trim(),t.materialLibraries);else if(Br.test(u))t.materialLibraries.push(u.substring(7).trim());else if(Gr.test(u))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(h==="s"){if(n=u.split(" "),n.length>1){const d=n[1].trim().toLowerCase();t.object.smooth=d!=="0"&&d!=="off"}else t.object.smooth=!0;const p=t.object.currentMaterial();p&&(p.smooth=t.object.smooth)}else{if(u==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+u+'"')}}t.finalize();const r=new Ve;if(r.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let a=0,c=t.objects.length;a<c;a++){const u=t.objects[a],h=u.geometry,p=u.materials,d=h.type==="Line",y=h.type==="Points";let E=!1;if(h.vertices.length===0)continue;const v=new ke;v.setAttribute("position",new Ee(h.vertices,3)),h.normals.length>0&&v.setAttribute("normal",new Ee(h.normals,3)),h.colors.length>0&&(E=!0,v.setAttribute("color",new Ee(h.colors,3))),h.hasUVIndices===!0&&v.setAttribute("uv",new Ee(h.uvs,2));const S=[];for(let k=0,F=p.length;k<F;k++){const U=p[k],Z=U.name+"_"+U.smooth+"_"+E;let j=t.materials[Z];if(this.materials!==null){if(j=this.materials.create(U.name),d&&j&&!(j instanceof st)){const K=new st;rt.prototype.copy.call(K,j),K.color.copy(j.color),j=K}else if(y&&j&&!(j instanceof Je)){const K=new Je({size:10,sizeAttenuation:!1});rt.prototype.copy.call(K,j),K.color.copy(j.color),K.map=j.map,j=K}}j===void 0&&(d?j=new st:y?j=new Je({size:1,sizeAttenuation:!1}):j=new Qe,j.name=U.name,j.flatShading=!U.smooth,j.vertexColors=E,t.materials[Z]=j),S.push(j)}let L;if(S.length>1){for(let k=0,F=p.length;k<F;k++){const U=p[k];v.addGroup(U.groupStart,U.groupCount,k)}d?L=new Ut(v,S):y?L=new gt(v,S):L=new yt(v,S)}else d?L=new Ut(v,S[0]):y?L=new gt(v,S[0]):L=new yt(v,S[0]);L.name=u.name,r.add(L)}else if(t.vertices.length>0){const a=new Je({size:1,sizeAttenuation:!1}),c=new ke;c.setAttribute("position",new Ee(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(c.setAttribute("color",new Ee(t.colors,3)),a.vertexColors=!0);const u=new gt(c,a);r.add(u)}return r}}const qr=Object.freeze(Object.defineProperty({__proto__:null,OBJLoader:Vr},Symbol.toStringTag,{value:"Module"}));export{Zr as D,Kr as E,Wr as F,Yr as G,qr as O};
