import{at as I,au as E,E as C,ap as U,o as x,d as R,aD as O,y as B,aE as N,Y as M}from"./three-B27hEisu.js";const P=new WeakMap;class j extends I{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,n,s,r){const o=new E(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,t=>{this.parse(t,n,r)},s,r)}parse(e,n,s=()=>{}){this.decodeDracoFile(e,n,null,null,C,s).catch(s)}decodeDracoFile(e,n,s,r,o=U,t=()=>{}){const i={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:r||this.defaultAttributeTypes,useUniqueIDs:!!s,vertexColorSpace:o};return this.decodeGeometry(e,i).then(n).catch(t)}decodeGeometry(e,n){const s=JSON.stringify(n);if(P.has(e)){const a=P.get(e);if(a.key===s)return a.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let r;const o=this.workerNextTaskID++,t=e.byteLength,i=this._getWorker(o,t).then(a=>(r=a,new Promise((u,c)=>{r._callbacks[o]={resolve:u,reject:c},r.postMessage({type:"decode",id:o,taskConfig:n,buffer:e},[e])}))).then(a=>this._createGeometry(a.geometry));return i.catch(()=>!0).then(()=>{r&&o&&this._releaseTask(r,o)}),P.set(e,{key:s,promise:i}),i}_createGeometry(e){const n=new x;e.index&&n.setIndex(new R(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const{name:r,array:o,itemSize:t,stride:i,vertexColorSpace:a}=e.attributes[s];let u;if(t===i)u=new R(o,t);else{const c=new O(o,i);u=new M(c,t,0)}r==="color"&&(this._assignVertexColorSpace(u,a),u.normalized=!(o instanceof Float32Array)),n.setAttribute(r,u)}return n}_assignVertexColorSpace(e,n){if(n!==C)return;const s=new B;for(let r=0,o=e.count;r<o;r++)s.fromBufferAttribute(e,r),N.colorSpaceToWorking(s,C),e.setXYZ(r,s.r,s.g,s.b)}_loadLibrary(e,n){const s=new E(this.manager);return s.setPath(this.decoderPath),s.setResponseType(n),s.setWithCredentials(this.withCredentials),new Promise((r,o)=>{s.load(e,r,void 0,o)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",n=[];return e?n.push(this._loadLibrary("draco_decoder.js","text")):(n.push(this._loadLibrary("draco_wasm_wrapper.js","text")),n.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(n).then(s=>{const r=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const o=G.toString(),t=["/* draco decoder */",r,"","/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([t]))}),this.decoderPending}_getWorker(e,n){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const r=new Worker(this.workerSourceURL);r._callbacks={},r._taskCosts={},r._taskLoad=0,r.postMessage({type:"init",decoderConfig:this.decoderConfig}),r.onmessage=function(o){const t=o.data;switch(t.type){case"decode":r._callbacks[t.id].resolve(t);break;case"error":r._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},this.workerPool.push(r)}else this.workerPool.sort(function(r,o){return r._taskLoad>o._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=n,s._taskLoad+=n,s})}_releaseTask(e,n){e._taskLoad-=e._taskCosts[n],delete e._callbacks[n],delete e._taskCosts[n]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function G(){let m,e;onmessage=function(t){const i=t.data;switch(i.type){case"init":m=i.decoderConfig,e=new Promise(function(c){m.onModuleLoaded=function(h){c({draco:h})},DracoDecoderModule(m)});break;case"decode":const a=i.buffer,u=i.taskConfig;e.then(c=>{const h=c.draco,d=new h.Decoder;try{const l=n(h,d,new Int8Array(a),u),g=l.attributes.map(f=>f.array.buffer);l.index&&g.push(l.index.array.buffer),self.postMessage({type:"decode",id:i.id,geometry:l},g)}catch(l){console.error(l),self.postMessage({type:"error",id:i.id,error:l.message})}finally{h.destroy(d)}});break}};function n(t,i,a,u){const c=u.attributeIDs,h=u.attributeTypes;let d,l;const g=i.GetEncodedGeometryType(a);if(g===t.TRIANGULAR_MESH)d=new t.Mesh,l=i.DecodeArrayToMesh(a,a.byteLength,d);else if(g===t.POINT_CLOUD)d=new t.PointCloud,l=i.DecodeArrayToPointCloud(a,a.byteLength,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!l.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+l.error_msg());const f={index:null,attributes:[]};for(const y in c){const w=self[h[y]];let _,p;if(u.useUniqueIDs)p=c[y],_=i.GetAttributeByUniqueId(d,p);else{if(p=i.GetAttributeId(d,t[c[y]]),p===-1)continue;_=i.GetAttribute(d,p)}const b=r(t,i,d,y,w,_);y==="color"&&(b.vertexColorSpace=u.vertexColorSpace),f.attributes.push(b)}return g===t.TRIANGULAR_MESH&&(f.index=s(t,i,d)),t.destroy(d),f}function s(t,i,a){const c=a.num_faces()*3,h=c*4,d=t._malloc(h);i.GetTrianglesUInt32Array(a,h,d);const l=new Uint32Array(t.HEAPF32.buffer,d,c).slice();return t._free(d),{array:l,itemSize:1}}function r(t,i,a,u,c,h){const d=a.num_points(),l=h.num_components(),g=o(t,c),f=l*c.BYTES_PER_ELEMENT,y=Math.ceil(f/4)*4,w=y/c.BYTES_PER_ELEMENT,_=d*f,p=d*y,b=t._malloc(_);i.GetAttributeDataArrayForAllPoints(a,h,g,_,b);const T=new c(t.HEAPF32.buffer,b,_/c.BYTES_PER_ELEMENT);let k;if(f===y)k=T.slice();else{k=new c(p/c.BYTES_PER_ELEMENT);let D=0;for(let A=0,S=T.length;A<S;A++){for(let L=0;L<l;L++)k[D+L]=T[A*l+L];D+=w}}return t._free(b),{name:u,count:d,itemSize:l,array:k,stride:w}}function o(t,i){switch(i){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}}export{j as DRACOLoader};
